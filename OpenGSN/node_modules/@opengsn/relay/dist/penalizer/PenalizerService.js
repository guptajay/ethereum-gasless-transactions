"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
// @ts-ignore
const abi_decoder_1 = __importDefault(require("abi-decoder"));
const crypto_1 = __importDefault(require("crypto"));
const ethereumjs_tx_1 = require("ethereumjs-tx");
const ethereumjs_util_1 = require("ethereumjs-util");
const ethUtils = __importStar(require("ethereumjs-util"));
const IPaymaster_json_1 = __importDefault(require("@opengsn/common/dist/interfaces/IPaymaster.json"));
const IRelayHub_json_1 = __importDefault(require("@opengsn/common/dist/interfaces/IRelayHub.json"));
const IStakeManager_json_1 = __importDefault(require("@opengsn/common/dist/interfaces/IStakeManager.json"));
const GSNContractsDataTypes_1 = require("@opengsn/common/dist/types/GSNContractsDataTypes");
const VersionsManager_1 = require("@opengsn/common/dist/VersionsManager");
const ErrorReplacerJSON_1 = require("@opengsn/common/dist/ErrorReplacerJSON");
const StoredTransaction_1 = require("../StoredTransaction");
const Utils_1 = require("@opengsn/common/dist/Utils");
const Version_1 = require("@opengsn/common/dist/Version");
const Constants_1 = require("@opengsn/common/dist/Constants");
abi_decoder_1.default.addABI(IRelayHub_json_1.default);
abi_decoder_1.default.addABI(IPaymaster_json_1.default);
abi_decoder_1.default.addABI(IStakeManager_json_1.default);
const INVALID_SIGNATURE = 'Transaction does not have a valid signature';
const UNKNOWN_WORKER = 'Transaction is sent by an unknown worker';
const UNSTAKED_RELAY = 'Transaction is sent by an unstaked relay';
const MINED_TRANSACTION = 'Transaction is the one mined on the current chain and no conflicting transaction is known to this server';
const NONCE_FORWARD = 'Transaction nonce is higher then current account nonce and no conflicting transaction is known to this server';
function createWeb3Transaction(transaction, rawTxOptions) {
    var _a;
    const gasPrice = '0x' + BigInt(transaction.gasPrice).toString(16);
    const value = '0x' + BigInt(transaction.value).toString(16);
    const txData = {
        gasLimit: transaction.gas,
        gasPrice,
        to: (_a = transaction.to) !== null && _a !== void 0 ? _a : '',
        data: transaction.input,
        nonce: transaction.nonce,
        value,
        // @ts-ignore
        v: transaction.v,
        // @ts-ignore
        r: transaction.r,
        // @ts-ignore
        s: transaction.s
    };
    return new ethereumjs_tx_1.Transaction(txData, rawTxOptions);
}
/**
 * types of penalization supported by a penalizer
 * string values are for logging purposes only
 */
var PenalizationTypes;
(function (PenalizationTypes) {
    PenalizationTypes["ILLEGAL_TRANSACTION"] = "penalizeIllegalTransaction";
    PenalizationTypes["REPEATED_NONCE"] = "penalizeRepeatedNonce";
})(PenalizationTypes || (PenalizationTypes = {}));
class PenalizerService {
    constructor(params, logger, config) {
        var _a;
        // TODO: TransactionManager is not integrated with Penalizer Service, so there is a duplication here
        /** Maps block where commitment becomes valid to penalization details */
        this.scheduledPenalizations = [];
        this.initialized = false;
        this.transactionManager = params.transactionManager;
        this.contractInteractor = params.contractInteractor;
        this.versionManager = new VersionsManager_1.VersionsManager(Version_1.gsnRuntimeVersion, (_a = config.requiredVersionRange) !== null && _a !== void 0 ? _a : Version_1.gsnRequiredVersion);
        this.config = config;
        this.txByNonceService = params.txByNonceService;
        this.managerAddress = this.transactionManager.managerKeyManager.getAddress(0);
        this.logger = logger;
    }
    async init(startWorker = true) {
        if (this.initialized) {
            return;
        }
        this.logger.info('Penalizer service initialized');
        if (startWorker) {
            // eslint-disable-next-line @typescript-eslint/no-misused-promises
            this.workerTask = setInterval(this.intervalHandler.bind(this), this.config.checkInterval);
            this.logger.debug(`Started checking for ready penalization commitments every ${this.config.checkInterval}ms`);
        }
        this.initialized = true;
    }
    stop() {
        if (this.workerTask != null) {
            clearInterval(this.workerTask);
        }
    }
    async penalizeRepeatedNonce(req) {
        if (!this.initialized) {
            throw new Error('PenalizerService is not initialized');
        }
        if (this.config.etherscanApiUrl.length === 0) {
            return {
                message: 'Etherscan API URL is not set on this server!'
            };
        }
        this.logger.info(`Validating tx ${req.signedTx}`);
        // deserialize the tx
        const rawTxOptions = this.contractInteractor.getRawTxOptions();
        const requestTx = new ethereumjs_tx_1.Transaction(req.signedTx, rawTxOptions);
        const validationResult = await this.validateTransaction(requestTx);
        if (!validationResult.valid) {
            return {
                message: validationResult.error
            };
        }
        const isMinedTx = await this.isTransactionMined(requestTx);
        if (isMinedTx) {
            return {
                message: MINED_TRANSACTION
            };
        }
        const relayWorker = ethereumjs_util_1.bufferToHex(requestTx.getSenderAddress());
        // read the relay worker's nonce from blockchain
        const currentNonce = await this.contractInteractor.getTransactionCount(relayWorker, 'pending');
        // if tx nonce > current nonce, publish tx and await
        // otherwise, get mined tx with same nonce. if equals (up to different gasPrice) to received tx, return.
        // Otherwise, penalize.
        const transactionNonce = ethereumjs_util_1.bufferToInt(requestTx.nonce);
        if (transactionNonce > currentNonce) {
            // TODO: store it, and see how sender behaves later...
            //  also, if we have already stored some transaction for this sender, check if these two are in nonce conflict.
            //  this flow has nothing to do with this particular penalization, so just default to 'storeTxForLater' or something
            return {
                message: NONCE_FORWARD
            };
        }
        // run penalize in view mode to see if penalizable
        const minedTransactionData = await this.txByNonceService.getTransactionByNonce(relayWorker, transactionNonce);
        if (minedTransactionData == null) {
            throw Error(`TxByNonce service failed to fetch tx with nonce ${transactionNonce} of relayer ${relayWorker}`);
        }
        const minedTx = await this.contractInteractor.getTransaction(minedTransactionData.hash);
        if (minedTx == null) {
            throw Error(`Failed to get transaction ${minedTransactionData.hash} from node`);
        }
        const minedTxBuffers = createWeb3Transaction(minedTx, rawTxOptions);
        const randomValue = ethereumjs_util_1.bufferToHex(crypto_1.default.randomBytes(32));
        const penalizationArguments = this.getPenalizeRepeatedNonceArguments(minedTxBuffers, requestTx, randomValue);
        const method = this.getMethod(PenalizationTypes.REPEATED_NONCE, penalizationArguments);
        const isValidPenalization = await this.validatePenalization(method);
        if (!validationResult.valid) {
            return {
                message: isValidPenalization.error
            };
        }
        const commitHash = this.calculateCommitHash(method);
        const delayedPenalization = {
            commitHash,
            type: PenalizationTypes.REPEATED_NONCE,
            methodArgs: penalizationArguments
        };
        const commitTxHash = await this.commitAndScheduleReveal(delayedPenalization);
        return { commitTxHash };
    }
    calculateCommitHash(method) {
        const msgData = method.encodeABI();
        const msgDataHash = `0x${ethUtils.keccak256(Buffer.from(Utils_1.removeHexPrefix(msgData), 'hex')).toString('hex')}`;
        return `0x${ethUtils.keccak256(Buffer.from(Utils_1.removeHexPrefix(msgDataHash + this.managerAddress.slice(2).toLowerCase()), 'hex')).toString('hex')}`;
    }
    async intervalHandler() {
        if (this.scheduledPenalizations.length === 0) {
            return [];
        }
        console.log('interval handler called');
        // step 1. see if sent some commitments and these are now mined
        await this.queryReadyBlocksForMinedCommitments();
        // step 2. now all commitments have a due date, let's see if any are up for penalization
        return await this.executeReadyPenalizations();
    }
    async executeReadyPenalizations() {
        const currentBlockNumber = await this.contractInteractor.getBlockNumber();
        const readyPenalizations = this.scheduledPenalizations.filter(it => {
            return it.readyBlockNumber != null && it.readyBlockNumber <= currentBlockNumber;
        });
        const executedPenalizations = [];
        for (const penalization of readyPenalizations) {
            // Remove ready penalizations from memory
            const index = this.scheduledPenalizations.indexOf(penalization);
            this.scheduledPenalizations.splice(index, 1);
            // now broadcast the penalization transaction
            const penalizationTxHash = await this.executeDelayedPenalization(penalization);
            executedPenalizations.push(penalizationTxHash);
        }
        return executedPenalizations;
    }
    /**
     * Note: this method modifies elements of {@link scheduledPenalizations} in-place
     */
    async queryReadyBlocksForMinedCommitments() {
        const unconfirmedPenalizations = this.scheduledPenalizations.filter(it => it.readyBlockNumber === undefined);
        const nonMinedCommitHashes = unconfirmedPenalizations.map(up => up.commitHash);
        if (unconfirmedPenalizations.length > 0) {
            // TODO: sanitize functional stuff
            const topics = [Utils_1.address2topic(this.managerAddress)];
            const commitments = await this.contractInteractor.getPastEventsForPenalizer([GSNContractsDataTypes_1.CommitAdded], topics, { fromBlock: 1 });
            const newlyMinedCommitments = commitments
                .filter(it => {
                return nonMinedCommitHashes.includes(it.returnValues.commitHash);
            });
            unconfirmedPenalizations.forEach(it => {
                const commitment = newlyMinedCommitments.find(nmc => nmc.returnValues.commitHash === it.commitHash);
                if (commitment != null) {
                    it.readyBlockNumber = commitment.returnValues.readyBlockNumber;
                }
            });
        }
    }
    async penalizeIllegalTransaction(req) {
        const rawTxOptions = this.contractInteractor.getRawTxOptions();
        const requestTx = new ethereumjs_tx_1.Transaction(req.signedTx, rawTxOptions);
        const validationResult = await this.validateTransaction(requestTx);
        if (!validationResult.valid) {
            return {
                message: validationResult.error
            };
        }
        // TODO: remove duplication
        const randomValue = ethereumjs_util_1.bufferToHex(crypto_1.default.randomBytes(32));
        const penalizationArguments = this.getPenalizeIllegalTransactionArguments(requestTx, randomValue);
        const method = this.getMethod(PenalizationTypes.ILLEGAL_TRANSACTION, penalizationArguments);
        const isValidPenalization = await this.validatePenalization(method);
        if (!isValidPenalization.valid) {
            return {
                message: isValidPenalization.error
            };
        }
        const commitHash = this.calculateCommitHash(method);
        const delayedPenalization = {
            commitHash,
            type: PenalizationTypes.ILLEGAL_TRANSACTION,
            methodArgs: penalizationArguments
        };
        const commitTxHash = await this.commitAndScheduleReveal(delayedPenalization);
        return { commitTxHash };
    }
    async commitAndScheduleReveal(delayedPenalization) {
        this.scheduledPenalizations.push(delayedPenalization);
        const method = this.contractInteractor.penalizerInstance.contract.methods.commit(delayedPenalization.commitHash);
        return await this.broadcastTransaction('commit', method);
    }
    async executeDelayedPenalization(delayedPenalization) {
        const method = this.getMethod(delayedPenalization.type, delayedPenalization.methodArgs);
        return await this.broadcastTransaction(delayedPenalization.type.valueOf(), method);
    }
    async broadcastTransaction(methodName, method) {
        const gasLimit = await this.transactionManager.attemptEstimateGas(methodName, method, this.managerAddress);
        const creationBlockNumber = await this.contractInteractor.getBlockNumber();
        const serverAction = StoredTransaction_1.ServerAction.PENALIZATION;
        const { signedTx, transactionHash } = await this.transactionManager.sendTransaction({
            signer: this.managerAddress,
            method,
            destination: this.contractInteractor.penalizerInstance.address,
            gasLimit,
            creationBlockNumber,
            serverAction
        });
        this.logger.debug(`penalization raw tx: ${signedTx} txHash: ${transactionHash}`);
        return transactionHash;
    }
    getPenalizeIllegalTransactionArguments(requestTx, randomValue) {
        const chainId = this.contractInteractor.chainId;
        const { data, signature } = Utils_1.getDataAndSignature(requestTx, chainId);
        return [
            data, signature, this.contractInteractor.relayHubInstance.address,
            randomValue
        ];
    }
    getPenalizeRepeatedNonceArguments(minedTx, requestTx, randomValue) {
        const chainId = this.contractInteractor.chainId;
        const { data: unsignedMinedTx, signature: minedTxSig } = Utils_1.getDataAndSignature(minedTx, chainId);
        const { data: unsignedRequestTx, signature: requestTxSig } = Utils_1.getDataAndSignature(requestTx, chainId);
        return [
            unsignedRequestTx, requestTxSig, unsignedMinedTx,
            minedTxSig, this.contractInteractor.relayHubInstance.address,
            randomValue
        ];
    }
    async validateTransaction(requestTx) {
        const txHash = requestTx.hash(true).toString('hex');
        if (!requestTx.verifySignature()) {
            return {
                valid: false,
                error: INVALID_SIGNATURE
            };
        }
        const relayWorker = ethereumjs_util_1.bufferToHex(requestTx.getSenderAddress());
        const relayManager = await this.contractInteractor.relayHubInstance.workerToManager(relayWorker);
        if (ethereumjs_util_1.isZeroAddress(relayManager)) {
            return {
                valid: false,
                error: UNKNOWN_WORKER
            };
        }
        const staked = await this.contractInteractor.relayHubInstance.isRelayManagerStaked(relayManager);
        if (!staked) {
            return {
                valid: false,
                error: UNSTAKED_RELAY
            };
        }
        this.logger.info(`Transaction ${txHash} is valid`);
        return { valid: true };
    }
    async isTransactionMined(requestTx) {
        const txFromNode = await this.contractInteractor.getTransaction(ethereumjs_util_1.bufferToHex(requestTx.hash(true)));
        return txFromNode != null;
    }
    async validatePenalization(method) {
        try {
            const res = await method.call({
                from: Constants_1.constants.ZERO_ADDRESS
            });
            this.logger.debug(`res is ${JSON.stringify(res)}`);
            return {
                valid: true
            };
        }
        catch (e) {
            const error = e instanceof Error ? e.message : JSON.stringify(e, ErrorReplacerJSON_1.replaceErrors);
            this.logger.debug(`view call to penalizeRepeatedNonce reverted with error message ${error}.\nTx not penalizable.`);
            return {
                valid: false,
                error
            };
        }
    }
    getMethod(penalizationTypes, methodArgs) {
        switch (penalizationTypes) {
            case PenalizationTypes.REPEATED_NONCE:
                return this.contractInteractor.penalizerInstance.contract.methods.penalizeRepeatedNonce(...methodArgs);
            case PenalizationTypes.ILLEGAL_TRANSACTION:
                return this.contractInteractor.penalizerInstance.contract.methods.penalizeIllegalTransaction(...methodArgs);
        }
    }
}
exports.PenalizerService = PenalizerService;
//# sourceMappingURL=PenalizerService.js.map