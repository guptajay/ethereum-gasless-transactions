"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const web3_utils_1 = require("web3-utils");
const web3_eth_abi_1 = __importDefault(require("web3-eth-abi"));
const HashcashPaymaster_json_1 = __importDefault(require("@opengsn/paymasters/build/contracts/HashcashPaymaster.json"));
const IForwarder_json_1 = __importDefault(require("@opengsn/common/dist/interfaces/IForwarder.json"));
/**
 * low-level hashcash calculation for the given address and nonce
 * This value should be passed as approvalData for the HashcashPaymaster
 * @param senderAddress the address of the sender
 * @param senderNonce the current nonce of the sender
 * @param difficulty target difficulty to meet
 * @param interval call the callback every that many iterations
 * @param callback async callback to call. return "false" to abort. true to continue
 * @return the approvalData value (bytes32 hash, uint256 counter)
 */
async function calculateHashcash(senderAddress, senderNonce, difficulty, interval, callback) {
    const diffMax = web3_utils_1.toBN(1).shln(256 - difficulty);
    let hashNonce = 0;
    let intervalCount = 0;
    while (true) {
        // @ts-ignore
        const params = web3_eth_abi_1.default.encodeParameters(['address', 'uint256', 'uint256'], [senderAddress, senderNonce, hashNonce]);
        const hash = web3_utils_1.keccak256(params);
        const val = web3_utils_1.toBN(hash);
        if (val.lt(diffMax)) {
            if (callback != null) {
                await callback(difficulty); // signal "done"
            }
            // @ts-ignore
            return web3_eth_abi_1.default.encodeParameters(['bytes32', 'uint256'], [hash, hashNonce]);
        }
        hashNonce++;
        if (interval != null && intervalCount++ > interval) {
            intervalCount = 0;
            const cbresp = await callback(difficulty, hashNonce);
            if (cbresp == null) {
                return '0x';
            }
        }
    }
}
exports.calculateHashcash = calculateHashcash;
/**
 * RelayProvider Helper: use to initialize
 * the asyncApprovalData, when using HashcashProvider.
 * NOTE: this will cause the method call to block until the calculation is finished.
 * @param difficulty level this hashcash instance requires. make sure this value is
 *  the same (or higher) as the provider requires, otherwise, you'll get a revert of
 *  "difficulty not met"
 *  @param interval call the callback function every that many iterations
 *  @param callback async callback to call. return false to abort calculation
 * @returns - an async function to pass as a parameter for "asyncApprovalData" of the
 *  RelayProvider. see the HashcashPaymaster.test.ts for usage example.
 */
function createHashcashAsyncApproval(difficulty, interval, callback) {
    return async function (relayRequest) {
        console.log('=== calculating approval');
        const { from: senderAddress, nonce: senderNonce } = relayRequest.request;
        const val = calculateHashcash(senderAddress, senderNonce, difficulty, interval, callback);
        console.log('=== done calculating approval');
        return await val;
    };
}
exports.createHashcashAsyncApproval = createHashcashAsyncApproval;
// helper: call the "call()" method, and throw the given string in case of error
// (most likely - object doens't support this method..)
function checkedCall(method, str) {
    try {
        return method.call();
    }
    catch (e) {
        console.log('==e', e);
        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
        throw new Error(str + ': ' + e);
    }
}
/**
 * calculate in advance async approval.
 * @param web3
 * @param senderAddr
 * @param recipientAddr the recipient address to use
 * @param forwarderAddress
 * @param hashcashPaymasterAddr the hashcash paymaster to work with
 * @param interval
 * @param callback
 */
async function calculateHashcashApproval(web3, senderAddr, recipientAddr, forwarderAddress, hashcashPaymasterAddr, interval, callback) {
    // @ts-ignore
    const paymaster = new web3.eth.Contract(HashcashPaymaster_json_1.default.abi, hashcashPaymasterAddr).methods;
    const difficulty = await checkedCall(paymaster.difficulty(), hashcashPaymasterAddr !== null && hashcashPaymasterAddr !== void 0 ? hashcashPaymasterAddr : 'undefined' + ': not A HashcashPaymaster');
    // @ts-ignore
    const forwarder = new web3.eth.Contract(IForwarder_json_1.default, forwarderAddress).methods;
    const nonce = await checkedCall(forwarder.getNonce(senderAddr), 'No getNonce()');
    console.log('calling with addr=', senderAddr, 'nonce=', nonce, 'fwd=', forwarderAddress, 'recipient=', recipientAddr);
    return await calculateHashcash(senderAddr, nonce, difficulty, interval, callback);
}
exports.calculateHashcashApproval = calculateHashcashApproval;
//# sourceMappingURL=HashCashApproval.js.map