"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const web3_1 = __importDefault(require("web3"));
const ethereumjs_util_1 = require("ethereumjs-util");
const common_1 = require("@opengsn/common");
const TypedRequestData_1 = require("@opengsn/common/dist/EIP712/TypedRequestData");
const PermitInterfaceDAI_json_1 = __importDefault(require("../build/contracts/PermitInterfaceDAI.json"));
const PermitInterfaceEIP2612_json_1 = __importDefault(require("../build/contracts/PermitInterfaceEIP2612.json"));
exports.DAI_CONTRACT_ADDRESS = '0x6B175474E89094C44Da98b954EedeAC495271d0F';
exports.WETH9_CONTRACT_ADDRESS = '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2';
exports.UNI_CONTRACT_ADDRESS = '0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984';
// USD Coin 0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48 false true
// Uniswap 0x1f9840a85d5af5bf1d1762f925bdaddc4201f984 true true
// Graph Token 0xc944e90c64b2c07662a292be6244bdf05cda44a7 true true
// Dai Stablecoin 0x6b175474e89094c44da98b954eedeac495271d0f true true
// renBTC 0xeb4c2781e4eba804ce9a9803c67d0893436bb27d false true
// Aave interest bearing CRV 0x8dae6cb04688c62d939ed9b68d32bc62e49970b1 false true
// Balancer 0xba100000625a3754423978a60c9317c58a424e3d false true
// 1INCH Token 0x111111111117dc0aa78b770fa6a738034120c302 false true
exports.UNISWAP_V3_QUOTER_CONTRACT_ADDRESS = '0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6';
exports.SWAP_ROUTER_CONTRACT_ADDRESS = '0xE592427A0AEce92De3Edee1F18E0157C05861564';
exports.GSN_FORWARDER_CONTRACT_ADDRESS = '0xAa3E82b4c4093b4bA13Cb5714382C99ADBf750cA';
exports.UNISWAP_V3_DAI_WETH_POOL_CONTRACT_ADDRESS = '0xC2e9F25Be6257c210d7Adf0D4Cd6E3E881ba25f8';
// price is approximate so USD can be used for any of the US Dollar stablecoins
exports.CHAINLINK_USD_ETH_FEED_CONTRACT_ADDRESS = '0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419';
exports.CHAINLINK_UNI_ETH_FEED_CONTRACT_ADDRESS = '0xD6aA3D25116d8dA79Ea0246c4826EB951872e02e';
exports.PERMIT_SIGNATURE_DAI = 'permit(address,address,uint256,uint256,bool,uint8,bytes32,bytes32)';
exports.PERMIT_SIGNATURE_EIP2612 = 'permit(address,address,uint256,uint256,uint8,bytes32,bytes32)';
function getDaiDomainSeparator() {
    return {
        name: 'Dai Stablecoin',
        version: '1',
        chainId: 1,
        verifyingContract: exports.DAI_CONTRACT_ADDRESS
    };
}
exports.getDaiDomainSeparator = getDaiDomainSeparator;
function getUniDomainSeparator() {
    return {
        name: 'Uniswap',
        chainId: 1,
        verifyingContract: exports.UNI_CONTRACT_ADDRESS
    };
}
exports.getUniDomainSeparator = getUniDomainSeparator;
exports.PermitTypeDai = [
    { name: 'holder', type: 'address' },
    { name: 'spender', type: 'address' },
    { name: 'nonce', type: 'uint256' },
    { name: 'expiry', type: 'uint256' },
    { name: 'allowed', type: 'bool' }
];
exports.PermitTypeEIP2612 = [
    { name: 'owner', type: 'address' },
    { name: 'spender', type: 'address' },
    { name: 'value', type: 'uint256' },
    { name: 'nonce', type: 'uint256' },
    { name: 'deadline', type: 'uint256' }
];
class TypedPermit {
    constructor(chainId, permitType, domain, permit, eip712DomainType = TypedRequestData_1.EIP712DomainType) {
        this.types = {
            EIP712Domain: eip712DomainType,
            Permit: permitType
        };
        this.domain = domain;
        this.primaryType = 'Permit';
        // in the signature, all "request" fields are flattened out at the top structure.
        // other params are inside "relayData" sub-type
        this.message = Object.assign({}, permit);
    }
}
exports.TypedPermit = TypedPermit;
async function signAndEncodeDaiPermit(holder, spender, token, expiry, web3Input, domainSeparator = getDaiDomainSeparator(), forceNonce, skipValidation = false) {
    const web3 = new web3_1.default(web3Input.currentProvider);
    const DaiContract = common_1.TruffleContract({
        contractName: 'DAIPermitInterface',
        abi: PermitInterfaceDAI_json_1.default.abi
    });
    DaiContract.setProvider(web3.currentProvider, undefined);
    const daiInstance = await DaiContract.at(token);
    const nonce = forceNonce !== null && forceNonce !== void 0 ? forceNonce : await daiInstance.nonces(holder);
    const chainId = await web3.eth.getChainId();
    const permit = {
        // TODO: not include holder as 'from', not pass 'from'
        from: holder,
        holder,
        spender,
        nonce,
        expiry,
        allowed: true
    };
    const dataToSign = new TypedPermit(chainId, exports.PermitTypeDai, domainSeparator, permit);
    const signature = await common_1.getEip712Signature(web3, dataToSign);
    const { r, s, v } = ethereumjs_util_1.fromRpcSig(signature);
    // we use 'estimateGas' to check against the permit method revert (hard to debug otherwise)
    if (!skipValidation) {
        await daiInstance.contract.methods.permit(holder, spender, nonce, expiry, true, v, r, s).estimateGas();
    }
    return daiInstance.contract.methods.permit(holder, spender, nonce, expiry, true, v, r, s).encodeABI();
}
exports.signAndEncodeDaiPermit = signAndEncodeDaiPermit;
async function signAndEncodeEIP2612Permit(owner, spender, token, value, deadline, web3Input, domainSeparator, domainType, forceNonce, skipValidation = false) {
    const web3 = new web3_1.default(web3Input.currentProvider);
    const EIP2612Contract = common_1.TruffleContract({
        contractName: 'EIP2612Contract',
        abi: PermitInterfaceEIP2612_json_1.default.abi
    });
    EIP2612Contract.setProvider(web3.currentProvider, undefined);
    const eip2612TokenInstance = await EIP2612Contract.at(token);
    const nonce = forceNonce !== null && forceNonce !== void 0 ? forceNonce : await eip2612TokenInstance.nonces(owner);
    const chainId = await web3.eth.getChainId();
    const permit = {
        // TODO: not include holder as 'from', not pass 'from'
        from: owner,
        owner,
        spender,
        nonce: nonce.toString(),
        deadline,
        value
    };
    const dataToSign = new TypedPermit(chainId, exports.PermitTypeEIP2612, domainSeparator, permit, domainType);
    const signature = await common_1.getEip712Signature(web3, dataToSign);
    const { r, s, v } = ethereumjs_util_1.fromRpcSig(signature);
    // we use 'estimateGas' to check against the permit method revert (hard to debug otherwise)
    if (!skipValidation) {
        await eip2612TokenInstance.contract.methods.permit(owner, spender, value, deadline, v, r, s).estimateGas();
    }
    return eip2612TokenInstance.contract.methods.permit(owner, spender, value, deadline, v, r, s).encodeABI();
}
exports.signAndEncodeEIP2612Permit = signAndEncodeEIP2612Permit;
//# sourceMappingURL=PermitPaymasterUtils.js.map