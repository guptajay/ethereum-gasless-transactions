{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ethereumjs_tx_1 = require(\"ethereumjs-tx\");\n\nconst ethereumjs_util_1 = require(\"ethereumjs-util\");\n\nconst Utils_1 = require(\"@opengsn/common/dist/Utils\");\n\nclass RelayedTransactionValidator {\n  constructor(contractInteractor, logger, config) {\n    this.contractInteractor = contractInteractor;\n    this.config = config;\n    this.logger = logger;\n  }\n  /**\n   * Decode the signed transaction returned from the Relay Server, compare it to the\n   * requested transaction and validate its signature.\n   * @returns a signed {@link Transaction} instance for broadcasting, or null if returned\n   * transaction is not valid.\n   */\n\n\n  validateRelayResponse(request, maxAcceptanceBudget, returnedTx) {\n    const transaction = new ethereumjs_tx_1.Transaction(returnedTx, this.contractInteractor.getRawTxOptions());\n    this.logger.info(`returnedTx:\n    v:        ${ethereumjs_util_1.bufferToHex(transaction.v)}\n    r:        ${ethereumjs_util_1.bufferToHex(transaction.r)}\n    s:        ${ethereumjs_util_1.bufferToHex(transaction.s)}\n    to:       ${ethereumjs_util_1.bufferToHex(transaction.to)}\n    data:     ${ethereumjs_util_1.bufferToHex(transaction.data)}\n    gasLimit: ${ethereumjs_util_1.bufferToHex(transaction.gasLimit)}\n    gasPrice: ${ethereumjs_util_1.bufferToHex(transaction.gasPrice)}\n    value:    ${ethereumjs_util_1.bufferToHex(transaction.value)}\n    `);\n    const signer = ethereumjs_util_1.bufferToHex(transaction.getSenderAddress());\n    const externalGasLimit = ethereumjs_util_1.bufferToHex(transaction.gasLimit);\n    const relayRequestAbiEncode = this.contractInteractor.encodeABI(maxAcceptanceBudget, request.relayRequest, request.metadata.signature, request.metadata.approvalData, externalGasLimit);\n    const relayHubAddress = this.contractInteractor.getDeployment().relayHubAddress;\n\n    if (relayHubAddress == null) {\n      throw new Error('no hub address');\n    }\n\n    if (Utils_1.isSameAddress(ethereumjs_util_1.bufferToHex(transaction.to), relayHubAddress) && relayRequestAbiEncode === ethereumjs_util_1.bufferToHex(transaction.data) && Utils_1.isSameAddress(request.relayRequest.relayData.relayWorker, signer)) {\n      this.logger.info('validateRelayResponse - valid transaction response'); // TODO: the relayServer encoder returns zero-length buffer for nonce=0.`\n\n      const receivedNonce = transaction.nonce.length === 0 ? 0 : transaction.nonce.readUIntBE(0, transaction.nonce.byteLength);\n\n      if (receivedNonce > request.metadata.relayMaxNonce) {\n        // TODO: need to validate that client retries the same request and doesn't double-spend.\n        // Note that this transaction is totally valid from the EVM's point of view\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        throw new Error(`Relay used a tx nonce higher than requested. Requested ${request.metadata.relayMaxNonce} got ${receivedNonce}`);\n      }\n\n      return true;\n    } else {\n      console.error('validateRelayResponse: req', relayRequestAbiEncode, relayHubAddress, request.relayRequest.relayData.relayWorker);\n      console.error('validateRelayResponse: rsp', ethereumjs_util_1.bufferToHex(transaction.data), ethereumjs_util_1.bufferToHex(transaction.to), signer);\n      return false;\n    }\n  }\n\n}\n\nexports.RelayedTransactionValidator = RelayedTransactionValidator;","map":{"version":3,"sources":["../src/RelayedTransactionValidator.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,eAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,MAAA,iBAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AAEA,MAAA,OAAA,GAAA,OAAA,CAAA,4BAAA,CAAA;;AAOA,MAAa,2BAAb,CAAwC;AAKtC,EAAA,WAAA,CAAa,kBAAb,EAAqD,MAArD,EAA8E,MAA9E,EAA+F;AAC7F,SAAK,kBAAL,GAA0B,kBAA1B;AACA,SAAK,MAAL,GAAc,MAAd;AACA,SAAK,MAAL,GAAc,MAAd;AACD;AAED;;;;;AAKG;;;AACH,EAAA,qBAAqB,CACnB,OADmB,EAEnB,mBAFmB,EAGnB,UAHmB,EAGU;AAE7B,UAAM,WAAW,GAAG,IAAI,eAAA,CAAA,WAAJ,CAAgB,UAAhB,EAA4B,KAAK,kBAAL,CAAwB,eAAxB,EAA5B,CAApB;AAEA,SAAK,MAAL,CAAY,IAAZ,CAAiB;gBACL,iBAAA,CAAA,WAAA,CAAY,WAAW,CAAC,CAAxB,CAA0B;gBAC1B,iBAAA,CAAA,WAAA,CAAY,WAAW,CAAC,CAAxB,CAA0B;gBAC1B,iBAAA,CAAA,WAAA,CAAY,WAAW,CAAC,CAAxB,CAA0B;gBAC1B,iBAAA,CAAA,WAAA,CAAY,WAAW,CAAC,EAAxB,CAA2B;gBAC3B,iBAAA,CAAA,WAAA,CAAY,WAAW,CAAC,IAAxB,CAA6B;gBAC7B,iBAAA,CAAA,WAAA,CAAY,WAAW,CAAC,QAAxB,CAAiC;gBACjC,iBAAA,CAAA,WAAA,CAAY,WAAW,CAAC,QAAxB,CAAiC;gBACjC,iBAAA,CAAA,WAAA,CAAY,WAAW,CAAC,KAAxB,CAA8B;AACzC,KATD;AAWA,UAAM,MAAM,GAAG,iBAAA,CAAA,WAAA,CAAY,WAAW,CAAC,gBAAZ,EAAZ,CAAf;AAEA,UAAM,gBAAgB,GAAG,iBAAA,CAAA,WAAA,CAAY,WAAW,CAAC,QAAxB,CAAzB;AACA,UAAM,qBAAqB,GAAG,KAAK,kBAAL,CAAwB,SAAxB,CAAkC,mBAAlC,EAAuD,OAAO,CAAC,YAA/D,EAA6E,OAAO,CAAC,QAAR,CAAiB,SAA9F,EAAyG,OAAO,CAAC,QAAR,CAAiB,YAA1H,EAAwI,gBAAxI,CAA9B;AAEA,UAAM,eAAe,GAAG,KAAK,kBAAL,CAAwB,aAAxB,GAAwC,eAAhE;;AACA,QAAI,eAAe,IAAI,IAAvB,EAA6B;AAC3B,YAAM,IAAI,KAAJ,CAAU,gBAAV,CAAN;AACD;;AAED,QACE,OAAA,CAAA,aAAA,CAAc,iBAAA,CAAA,WAAA,CAAY,WAAW,CAAC,EAAxB,CAAd,EAA2C,eAA3C,KACA,qBAAqB,KAAK,iBAAA,CAAA,WAAA,CAAY,WAAW,CAAC,IAAxB,CAD1B,IAEA,OAAA,CAAA,aAAA,CAAc,OAAO,CAAC,YAAR,CAAqB,SAArB,CAA+B,WAA7C,EAA0D,MAA1D,CAHF,EAIE;AACA,WAAK,MAAL,CAAY,IAAZ,CAAiB,oDAAjB,EADA,CAGA;;AACA,YAAM,aAAa,GAAG,WAAW,CAAC,KAAZ,CAAkB,MAAlB,KAA6B,CAA7B,GAAiC,CAAjC,GAAqC,WAAW,CAAC,KAAZ,CAAkB,UAAlB,CAA6B,CAA7B,EAAgC,WAAW,CAAC,KAAZ,CAAkB,UAAlD,CAA3D;;AACA,UAAI,aAAa,GAAG,OAAO,CAAC,QAAR,CAAiB,aAArC,EAAoD;AAClD;AACA;AAEA;AACA,cAAM,IAAI,KAAJ,CAAU,0DAA0D,OAAO,CAAC,QAAR,CAAiB,aAAa,QAAQ,aAAa,EAAvH,CAAN;AACD;;AAED,aAAO,IAAP;AACD,KAlBD,MAkBO;AACL,MAAA,OAAO,CAAC,KAAR,CAAc,4BAAd,EAA4C,qBAA5C,EAAmE,eAAnE,EAAoF,OAAO,CAAC,YAAR,CAAqB,SAArB,CAA+B,WAAnH;AACA,MAAA,OAAO,CAAC,KAAR,CAAc,4BAAd,EAA4C,iBAAA,CAAA,WAAA,CAAY,WAAW,CAAC,IAAxB,CAA5C,EAA2E,iBAAA,CAAA,WAAA,CAAY,WAAW,CAAC,EAAxB,CAA3E,EAAwG,MAAxG;AACA,aAAO,KAAP;AACD;AACF;;AApEqC;;AAAxC,OAAA,CAAA,2BAAA,GAAA,2BAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ethereumjs_tx_1 = require(\"ethereumjs-tx\");\nconst ethereumjs_util_1 = require(\"ethereumjs-util\");\nconst Utils_1 = require(\"@opengsn/common/dist/Utils\");\nclass RelayedTransactionValidator {\n    constructor(contractInteractor, logger, config) {\n        this.contractInteractor = contractInteractor;\n        this.config = config;\n        this.logger = logger;\n    }\n    /**\n     * Decode the signed transaction returned from the Relay Server, compare it to the\n     * requested transaction and validate its signature.\n     * @returns a signed {@link Transaction} instance for broadcasting, or null if returned\n     * transaction is not valid.\n     */\n    validateRelayResponse(request, maxAcceptanceBudget, returnedTx) {\n        const transaction = new ethereumjs_tx_1.Transaction(returnedTx, this.contractInteractor.getRawTxOptions());\n        this.logger.info(`returnedTx:\n    v:        ${ethereumjs_util_1.bufferToHex(transaction.v)}\n    r:        ${ethereumjs_util_1.bufferToHex(transaction.r)}\n    s:        ${ethereumjs_util_1.bufferToHex(transaction.s)}\n    to:       ${ethereumjs_util_1.bufferToHex(transaction.to)}\n    data:     ${ethereumjs_util_1.bufferToHex(transaction.data)}\n    gasLimit: ${ethereumjs_util_1.bufferToHex(transaction.gasLimit)}\n    gasPrice: ${ethereumjs_util_1.bufferToHex(transaction.gasPrice)}\n    value:    ${ethereumjs_util_1.bufferToHex(transaction.value)}\n    `);\n        const signer = ethereumjs_util_1.bufferToHex(transaction.getSenderAddress());\n        const externalGasLimit = ethereumjs_util_1.bufferToHex(transaction.gasLimit);\n        const relayRequestAbiEncode = this.contractInteractor.encodeABI(maxAcceptanceBudget, request.relayRequest, request.metadata.signature, request.metadata.approvalData, externalGasLimit);\n        const relayHubAddress = this.contractInteractor.getDeployment().relayHubAddress;\n        if (relayHubAddress == null) {\n            throw new Error('no hub address');\n        }\n        if (Utils_1.isSameAddress(ethereumjs_util_1.bufferToHex(transaction.to), relayHubAddress) &&\n            relayRequestAbiEncode === ethereumjs_util_1.bufferToHex(transaction.data) &&\n            Utils_1.isSameAddress(request.relayRequest.relayData.relayWorker, signer)) {\n            this.logger.info('validateRelayResponse - valid transaction response');\n            // TODO: the relayServer encoder returns zero-length buffer for nonce=0.`\n            const receivedNonce = transaction.nonce.length === 0 ? 0 : transaction.nonce.readUIntBE(0, transaction.nonce.byteLength);\n            if (receivedNonce > request.metadata.relayMaxNonce) {\n                // TODO: need to validate that client retries the same request and doesn't double-spend.\n                // Note that this transaction is totally valid from the EVM's point of view\n                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                throw new Error(`Relay used a tx nonce higher than requested. Requested ${request.metadata.relayMaxNonce} got ${receivedNonce}`);\n            }\n            return true;\n        }\n        else {\n            console.error('validateRelayResponse: req', relayRequestAbiEncode, relayHubAddress, request.relayRequest.relayData.relayWorker);\n            console.error('validateRelayResponse: rsp', ethereumjs_util_1.bufferToHex(transaction.data), ethereumjs_util_1.bufferToHex(transaction.to), signer);\n            return false;\n        }\n    }\n}\nexports.RelayedTransactionValidator = RelayedTransactionValidator;\n//# sourceMappingURL=RelayedTransactionValidator.js.map"]},"metadata":{},"sourceType":"script"}