{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nconst ethereumjs_tx_1 = require(\"ethereumjs-tx\");\n\nconst ethereumjs_util_1 = require(\"ethereumjs-util\");\n\nconst ContractInteractor_1 = require(\"@opengsn/common/dist/ContractInteractor\");\n\nconst VersionsManager_1 = require(\"@opengsn/common/dist/VersionsManager\");\n\nconst Utils_1 = require(\"@opengsn/common/dist/Utils\");\n\nconst Version_1 = require(\"@opengsn/common/dist/Version\");\n\nconst AccountManager_1 = require(\"./AccountManager\");\n\nconst HttpClient_1 = require(\"@opengsn/common/dist/HttpClient\");\n\nconst HttpWrapper_1 = require(\"@opengsn/common/dist/HttpWrapper\");\n\nconst RelaySelectionManager_1 = require(\"./RelaySelectionManager\");\n\nconst RelayedTransactionValidator_1 = require(\"./RelayedTransactionValidator\");\n\nconst KnownRelaysManager_1 = require(\"./KnownRelaysManager\");\n\nconst ClientWinstonLogger_1 = require(\"./ClientWinstonLogger\");\n\nconst GSNConfigurator_1 = require(\"./GSNConfigurator\");\n\nconst GsnEvents_1 = require(\"./GsnEvents\"); // forwarder requests are signed with expiration time.\n\n\nconst REQUEST_VALID_BLOCKS = 6000; // roughly a day\n// generate \"approvalData\" and \"paymasterData\" for a request.\n// both are bytes arrays. paymasterData is part of the client request.\n// approvalData is created after request is filled and signed.\n\nexports.EmptyDataCallback = async () => {\n  return '0x';\n};\n\nexports.GasPricePingFilter = (pingResponse, gsnTransactionDetails) => {\n  if (gsnTransactionDetails.gasPrice != null && parseInt(pingResponse.minGasPrice) > parseInt(gsnTransactionDetails.gasPrice)) {\n    throw new Error(`Proposed gas price: ${gsnTransactionDetails.gasPrice}; relay's MinGasPrice: ${pingResponse.minGasPrice}`);\n  }\n};\n\nclass RelayClient {\n  constructor(rawConstructorInput) {\n    var _a, _b, _c, _d;\n\n    this.emitter = new events_1.EventEmitter();\n    this.initialized = false; // TODO: backwards-compatibility 102 - remove on next version bump\n\n    if (arguments[0] == null || arguments[0].send != null || arguments[2] != null) {\n      throw new Error('Sorry, but the constructor parameters of the RelayClient class have changed. See \"GSNUnresolvedConstructorInput\" interface for details.');\n    }\n\n    this.rawConstructorInput = rawConstructorInput;\n    this.logger = (_b = (_a = rawConstructorInput.overrideDependencies) === null || _a === void 0 ? void 0 : _a.logger) !== null && _b !== void 0 ? _b : ClientWinstonLogger_1.createClientLogger((_d = (_c = rawConstructorInput.config) === null || _c === void 0 ? void 0 : _c.loggerConfiguration) !== null && _d !== void 0 ? _d : GSNConfigurator_1.defaultLoggerConfiguration);\n  }\n\n  async init() {\n    if (this.initialized) {\n      throw new Error('init() already called');\n    }\n\n    this.initializingPromise = this._initInternal();\n    await this.initializingPromise;\n    this.initialized = true;\n    return this;\n  }\n\n  async _initInternal() {\n    this.emit(new GsnEvents_1.GsnInitEvent());\n    this.config = await this._resolveConfiguration(this.rawConstructorInput);\n    this.dependencies = await this._resolveDependencies(this.rawConstructorInput);\n  }\n  /**\n   * register a listener for GSN events\n   * @see GsnEvent and its subclasses for emitted events\n   * @param handler callback function to handle events\n   */\n\n\n  registerEventListener(handler) {\n    this.emitter.on('gsn', handler);\n  }\n  /**\n   * unregister previously registered event listener\n   * @param handler callback function to unregister\n   */\n\n\n  unregisterEventListener(handler) {\n    this.emitter.off('gsn', handler);\n  }\n\n  emit(event) {\n    this.emitter.emit('gsn', event);\n  }\n  /**\n   * In case Relay Server does not broadcast the signed transaction to the network,\n   * client also broadcasts the same transaction. If the transaction fails with nonce\n   * error, it indicates Relay may have signed multiple transactions with same nonce,\n   * causing a DoS attack.\n   *\n   * @param {*} transaction - actual Ethereum transaction, signed by a relay\n   */\n\n\n  async _broadcastRawTx(transaction) {\n    const rawTx = '0x' + transaction.serialize().toString('hex');\n    const txHash = '0x' + transaction.hash(true).toString('hex');\n    this.logger.info(`Broadcasting raw transaction signed by relay. TxHash: ${txHash}`);\n\n    try {\n      if (await this._isAlreadySubmitted(txHash)) {\n        return {\n          hasReceipt: true\n        };\n      } // can't find the TX in the mempool. broadcast it ourselves.\n\n\n      await this.dependencies.contractInteractor.sendSignedTransaction(rawTx);\n      return {\n        hasReceipt: true\n      };\n    } catch (broadcastError) {\n      // don't display error for the known-good cases\n      if ((broadcastError === null || broadcastError === void 0 ? void 0 : broadcastError.message.match(/the tx doesn't have the correct nonce|known transaction/)) != null) {\n        return {\n          hasReceipt: false,\n          wrongNonce: true,\n          broadcastError\n        };\n      }\n\n      return {\n        hasReceipt: false,\n        broadcastError\n      };\n    }\n  }\n\n  async _isAlreadySubmitted(txHash) {\n    const [txMinedReceipt, pendingBlock] = await Promise.all([this.dependencies.contractInteractor.web3.eth.getTransactionReceipt(txHash), // mempool transactions\n    this.dependencies.contractInteractor.web3.eth.getBlock('pending')]);\n\n    if (txMinedReceipt != null) {\n      return true;\n    }\n\n    return pendingBlock.transactions.includes(txHash);\n  }\n\n  async relayTransaction(gsnTransactionDetails) {\n    var _a, _b;\n\n    if (!this.initialized) {\n      if (this.initializingPromise == null) {\n        this._warn('suggestion: call RelayProvider.init()/RelayClient.init() in advance (to make first request faster)');\n      }\n\n      await this.init();\n    } // TODO: should have a better strategy to decide how often to refresh known relays\n\n\n    this.emit(new GsnEvents_1.GsnRefreshRelaysEvent());\n    await this.dependencies.knownRelaysManager.refresh();\n    gsnTransactionDetails.gasPrice = (_a = gsnTransactionDetails.forceGasPrice) !== null && _a !== void 0 ? _a : await this._calculateGasPrice();\n\n    if (gsnTransactionDetails.gas == null) {\n      const estimated = await this.dependencies.contractInteractor.estimateGas(gsnTransactionDetails);\n      gsnTransactionDetails.gas = `0x${estimated.toString(16)}`;\n    }\n\n    const relaySelectionManager = await new RelaySelectionManager_1.RelaySelectionManager(gsnTransactionDetails, this.dependencies.knownRelaysManager, this.dependencies.httpClient, this.dependencies.pingFilter, this.logger, this.config).init();\n    const count = relaySelectionManager.relaysLeft().length;\n    this.emit(new GsnEvents_1.GsnDoneRefreshRelaysEvent(count));\n\n    if (count === 0) {\n      throw new Error('no registered relayers');\n    }\n\n    const relayingErrors = new Map();\n    const auditPromises = [];\n\n    while (true) {\n      let relayingAttempt;\n      const activeRelay = await relaySelectionManager.selectNextRelay();\n\n      if (activeRelay != null) {\n        this.emit(new GsnEvents_1.GsnNextRelayEvent(activeRelay.relayInfo.relayUrl));\n        relayingAttempt = await this._attemptRelay(activeRelay, gsnTransactionDetails).catch(error => ({\n          error\n        }));\n\n        if (relayingAttempt.auditPromise != null) {\n          auditPromises.push(relayingAttempt.auditPromise);\n        }\n\n        if (relayingAttempt.transaction == null) {\n          relayingErrors.set(activeRelay.relayInfo.relayUrl, (_b = relayingAttempt.error) !== null && _b !== void 0 ? _b : new Error('No error reason was given'));\n          continue;\n        }\n      }\n\n      return {\n        transaction: relayingAttempt === null || relayingAttempt === void 0 ? void 0 : relayingAttempt.transaction,\n        relayingErrors,\n        auditPromises,\n        pingErrors: relaySelectionManager.errors\n      };\n    }\n  }\n\n  _warn(msg) {\n    this.logger.warn(msg);\n  }\n\n  async _calculateGasPrice() {\n    const pct = this.config.gasPriceFactorPercent;\n    const networkGasPrice = await this.dependencies.contractInteractor.getGasPrice();\n    let gasPrice = Math.round(parseInt(networkGasPrice) * (pct + 100) / 100);\n\n    if (this.config.minGasPrice != null && gasPrice < this.config.minGasPrice) {\n      gasPrice = this.config.minGasPrice;\n    }\n\n    return `0x${gasPrice.toString(16)}`;\n  }\n\n  async _attemptRelay(relayInfo, gsnTransactionDetails) {\n    this.logger.info(`attempting relay: ${JSON.stringify(relayInfo)} transaction: ${JSON.stringify(gsnTransactionDetails)}`);\n    const maxAcceptanceBudget = parseInt(relayInfo.pingResponse.maxAcceptanceBudget);\n    const httpRequest = await this._prepareRelayHttpRequest(relayInfo, gsnTransactionDetails);\n    this.emit(new GsnEvents_1.GsnValidateRequestEvent());\n    const acceptRelayCallResult = await this.dependencies.contractInteractor.validateRelayCall(maxAcceptanceBudget, httpRequest.relayRequest, httpRequest.metadata.signature, httpRequest.metadata.approvalData, this.config.maxViewableGasLimit);\n\n    if (!acceptRelayCallResult.paymasterAccepted) {\n      let message;\n\n      if (acceptRelayCallResult.reverted) {\n        message = 'local view call to \\'relayCall()\\' reverted';\n      } else {\n        message = 'paymaster rejected in local view call to \\'relayCall()\\' ';\n      }\n\n      return {\n        error: new Error(`${message}: ${Utils_1.decodeRevertReason(acceptRelayCallResult.returnValue)}`)\n      };\n    }\n\n    let hexTransaction;\n    let transaction;\n    let auditPromise;\n    this.emit(new GsnEvents_1.GsnSendToRelayerEvent(relayInfo.relayInfo.relayUrl));\n\n    try {\n      hexTransaction = await this.dependencies.httpClient.relayTransaction(relayInfo.relayInfo.relayUrl, httpRequest);\n      transaction = new ethereumjs_tx_1.Transaction(hexTransaction, this.dependencies.contractInteractor.getRawTxOptions());\n      auditPromise = this.auditTransaction(hexTransaction, relayInfo.relayInfo.relayUrl).then(penalizeResponse => {\n        if (penalizeResponse.commitTxHash != null) {\n          const txHash = ethereumjs_util_1.bufferToHex(transaction.hash(true));\n          this.logger.error(`The transaction with id: ${txHash} was penalized! Penalization commitment tx id: ${penalizeResponse.commitTxHash}`);\n        }\n\n        return penalizeResponse;\n      });\n    } catch (error) {\n      if ((error === null || error === void 0 ? void 0 : error.message) == null || error.message.indexOf('timeout') !== -1) {\n        this.dependencies.knownRelaysManager.saveRelayFailure(new Date().getTime(), relayInfo.relayInfo.relayManager, relayInfo.relayInfo.relayUrl);\n      }\n\n      this.logger.info(`relayTransaction: ${JSON.stringify(httpRequest)}`);\n      return {\n        error\n      };\n    }\n\n    if (!this.dependencies.transactionValidator.validateRelayResponse(httpRequest, maxAcceptanceBudget, hexTransaction)) {\n      this.emit(new GsnEvents_1.GsnRelayerResponseEvent(false));\n      this.dependencies.knownRelaysManager.saveRelayFailure(new Date().getTime(), relayInfo.relayInfo.relayManager, relayInfo.relayInfo.relayUrl);\n      return {\n        auditPromise,\n        error: new Error('Returned transaction did not pass validation')\n      };\n    }\n\n    this.emit(new GsnEvents_1.GsnRelayerResponseEvent(true));\n    await this._broadcastRawTx(transaction);\n    return {\n      auditPromise,\n      transaction\n    };\n  }\n\n  async _prepareRelayHttpRequest(relayInfo, gsnTransactionDetails) {\n    var _a, _b, _c;\n\n    const relayHubAddress = this.dependencies.contractInteractor.getDeployment().relayHubAddress;\n    const forwarder = (_a = gsnTransactionDetails.forwarder) !== null && _a !== void 0 ? _a : this.dependencies.contractInteractor.getDeployment().forwarderAddress;\n    const paymaster = (_b = gsnTransactionDetails.paymaster) !== null && _b !== void 0 ? _b : this.dependencies.contractInteractor.getDeployment().paymasterAddress;\n\n    if (relayHubAddress == null || paymaster == null || forwarder == null) {\n      throw new Error('Contract addresses are not initialized!');\n    } // valid that many blocks into the future.\n\n\n    const validUntilPromise = this.dependencies.contractInteractor.getBlockNumber().then(num => (num + REQUEST_VALID_BLOCKS).toString());\n    const senderNonce = await this.dependencies.contractInteractor.getSenderNonce(gsnTransactionDetails.from, forwarder);\n    const relayWorker = relayInfo.pingResponse.relayWorkerAddress;\n    const gasPriceHex = gsnTransactionDetails.gasPrice;\n    const gasLimitHex = gsnTransactionDetails.gas;\n\n    if (gasPriceHex == null || gasLimitHex == null) {\n      throw new Error('RelayClient internal exception. Gas price or gas limit still not calculated. Cannot happen.');\n    }\n\n    if (gasPriceHex.indexOf('0x') !== 0) {\n      throw new Error(`Invalid gasPrice hex string: ${gasPriceHex}`);\n    }\n\n    if (gasLimitHex.indexOf('0x') !== 0) {\n      throw new Error(`Invalid gasLimit hex string: ${gasLimitHex}`);\n    }\n\n    const gasLimit = parseInt(gasLimitHex, 16).toString();\n    const gasPrice = parseInt(gasPriceHex, 16).toString();\n    const value = (_c = gsnTransactionDetails.value) !== null && _c !== void 0 ? _c : '0';\n    const relayRequest = {\n      request: {\n        to: gsnTransactionDetails.to,\n        data: gsnTransactionDetails.data,\n        from: gsnTransactionDetails.from,\n        value: value,\n        nonce: senderNonce,\n        gas: gasLimit,\n        validUntil: await validUntilPromise\n      },\n      relayData: {\n        pctRelayFee: relayInfo.relayInfo.pctRelayFee,\n        baseRelayFee: relayInfo.relayInfo.baseRelayFee,\n        gasPrice,\n        paymaster,\n        paymasterData: '',\n        clientId: this.config.clientId,\n        forwarder,\n        relayWorker\n      }\n    }; // put paymasterData into struct before signing\n\n    relayRequest.relayData.paymasterData = await this.dependencies.asyncPaymasterData(relayRequest);\n    this.emit(new GsnEvents_1.GsnSignRequestEvent());\n    const signature = await this.dependencies.accountManager.sign(relayRequest);\n    const approvalData = await this.dependencies.asyncApprovalData(relayRequest); // max nonce is not signed, as contracts cannot access addresses' nonces.\n\n    const transactionCount = await this.dependencies.contractInteractor.getTransactionCount(relayWorker);\n    const relayMaxNonce = transactionCount + this.config.maxRelayNonceGap; // TODO: the server accepts a flat object, and that is why this code looks like shit.\n    //  Must teach server to accept correct types\n\n    const metadata = {\n      relayHubAddress,\n      signature,\n      approvalData,\n      relayMaxNonce\n    };\n    const httpRequest = {\n      relayRequest,\n      metadata\n    };\n    this.logger.info(`Created HTTP relay request: ${JSON.stringify(httpRequest)}`);\n    return httpRequest;\n  }\n\n  newAccount() {\n    this._verifyInitialized();\n\n    return this.dependencies.accountManager.newAccount();\n  }\n\n  addAccount(privateKey) {\n    this._verifyInitialized();\n\n    this.dependencies.accountManager.addAccount(privateKey);\n  }\n\n  _verifyInitialized() {\n    if (!this.initialized) {\n      throw new Error('not initialized. must call RelayClient.init()');\n    }\n  }\n\n  async auditTransaction(hexTransaction, sourceRelayUrl) {\n    const auditors = this.dependencies.knownRelaysManager.getAuditors([sourceRelayUrl]);\n    let failedAuditorsCount = 0;\n\n    for (const auditor of auditors) {\n      try {\n        const penalizeResponse = await this.dependencies.httpClient.auditTransaction(auditor, hexTransaction);\n\n        if (penalizeResponse.commitTxHash != null) {\n          return penalizeResponse;\n        }\n      } catch (e) {\n        failedAuditorsCount++;\n        this.logger.info(`Audit call failed for relay at URL: ${auditor}. Failed audit calls: ${failedAuditorsCount}/${auditors.length}`);\n      }\n    }\n\n    if (auditors.length === failedAuditorsCount && failedAuditorsCount !== 0) {\n      this.logger.error('All auditors failed!');\n    }\n\n    return {\n      message: `Transaction was not audited. Failed audit calls: ${failedAuditorsCount}/${auditors.length}`\n    };\n  }\n\n  getUnderlyingProvider() {\n    return this.rawConstructorInput.provider;\n  }\n\n  async _resolveConfiguration(_ref) {\n    let {\n      provider,\n      config = {}\n    } = _ref;\n\n    var _a, _b;\n\n    const isMetamask = provider.isMetaMask; // provide defaults valid for metamask (unless explicitly specified values)\n\n    const methodSuffix = (_a = config.methodSuffix) !== null && _a !== void 0 ? _a : isMetamask ? '_v4' : GSNConfigurator_1.defaultGsnConfig.methodSuffix;\n    const jsonStringifyRequest = (_b = config.jsonStringifyRequest) !== null && _b !== void 0 ? _b : isMetamask ? true : GSNConfigurator_1.defaultGsnConfig.jsonStringifyRequest;\n    const resolvedConfig = {\n      methodSuffix,\n      jsonStringifyRequest\n    };\n    return Object.assign(Object.assign(Object.assign({}, GSNConfigurator_1.defaultGsnConfig), resolvedConfig), config);\n  }\n\n  async _resolveDependencies(_ref2) {\n    let {\n      provider,\n      config = {},\n      overrideDependencies = {}\n    } = _ref2;\n\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n\n    const versionManager = new VersionsManager_1.VersionsManager(Version_1.gsnRuntimeVersion, (_a = config.requiredVersionRange) !== null && _a !== void 0 ? _a : Version_1.gsnRequiredVersion);\n    const contractInteractor = (_b = overrideDependencies === null || overrideDependencies === void 0 ? void 0 : overrideDependencies.contractInteractor) !== null && _b !== void 0 ? _b : await new ContractInteractor_1.ContractInteractor({\n      provider,\n      versionManager,\n      logger: this.logger,\n      maxPageSize: this.config.pastEventsQueryMaxPageSize,\n      deployment: {\n        paymasterAddress: config === null || config === void 0 ? void 0 : config.paymasterAddress\n      }\n    }).init();\n    const accountManager = (_c = overrideDependencies === null || overrideDependencies === void 0 ? void 0 : overrideDependencies.accountManager) !== null && _c !== void 0 ? _c : new AccountManager_1.AccountManager(provider, contractInteractor.chainId, this.config);\n    const httpClient = (_d = overrideDependencies === null || overrideDependencies === void 0 ? void 0 : overrideDependencies.httpClient) !== null && _d !== void 0 ? _d : new HttpClient_1.HttpClient(new HttpWrapper_1.HttpWrapper(), this.logger);\n    const pingFilter = (_e = overrideDependencies === null || overrideDependencies === void 0 ? void 0 : overrideDependencies.pingFilter) !== null && _e !== void 0 ? _e : exports.GasPricePingFilter;\n    const relayFilter = (_f = overrideDependencies === null || overrideDependencies === void 0 ? void 0 : overrideDependencies.relayFilter) !== null && _f !== void 0 ? _f : KnownRelaysManager_1.EmptyFilter;\n    const asyncApprovalData = (_g = overrideDependencies === null || overrideDependencies === void 0 ? void 0 : overrideDependencies.asyncApprovalData) !== null && _g !== void 0 ? _g : exports.EmptyDataCallback;\n    const asyncPaymasterData = (_h = overrideDependencies === null || overrideDependencies === void 0 ? void 0 : overrideDependencies.asyncPaymasterData) !== null && _h !== void 0 ? _h : exports.EmptyDataCallback;\n    const scoreCalculator = (_j = overrideDependencies === null || overrideDependencies === void 0 ? void 0 : overrideDependencies.scoreCalculator) !== null && _j !== void 0 ? _j : KnownRelaysManager_1.DefaultRelayScore;\n    const knownRelaysManager = (_k = overrideDependencies === null || overrideDependencies === void 0 ? void 0 : overrideDependencies.knownRelaysManager) !== null && _k !== void 0 ? _k : new KnownRelaysManager_1.KnownRelaysManager(contractInteractor, this.logger, this.config, relayFilter);\n    const transactionValidator = (_l = overrideDependencies === null || overrideDependencies === void 0 ? void 0 : overrideDependencies.transactionValidator) !== null && _l !== void 0 ? _l : new RelayedTransactionValidator_1.RelayedTransactionValidator(contractInteractor, this.logger, this.config);\n    return {\n      logger: this.logger,\n      httpClient,\n      contractInteractor,\n      knownRelaysManager,\n      accountManager,\n      transactionValidator,\n      pingFilter,\n      relayFilter,\n      asyncApprovalData,\n      asyncPaymasterData,\n      scoreCalculator\n    };\n  }\n\n}\n\nexports.RelayClient = RelayClient;\n\nfunction _dumpRelayingResult(relayingResult) {\n  let str = '';\n\n  if (relayingResult.pingErrors.size > 0) {\n    str += `Ping errors (${relayingResult.pingErrors.size}):`;\n    Array.from(relayingResult.pingErrors.keys()).forEach(e => {\n      var _a, _b;\n\n      const err = relayingResult.pingErrors.get(e);\n      const error = (_b = (_a = err === null || err === void 0 ? void 0 : err.message) !== null && _a !== void 0 ? _a : err === null || err === void 0 ? void 0 : err.toString()) !== null && _b !== void 0 ? _b : '';\n      str += `\\n${e} => ${error}\\n`;\n    });\n  }\n\n  if (relayingResult.relayingErrors.size > 0) {\n    str += `Relaying errors (${relayingResult.relayingErrors.size}):\\n`;\n    Array.from(relayingResult.relayingErrors.keys()).forEach(e => {\n      var _a, _b;\n\n      const err = relayingResult.relayingErrors.get(e);\n      const error = (_b = (_a = err === null || err === void 0 ? void 0 : err.message) !== null && _a !== void 0 ? _a : err === null || err === void 0 ? void 0 : err.toString()) !== null && _b !== void 0 ? _b : '';\n      str += `${e} => ${error}`;\n    });\n  }\n\n  return str;\n}\n\nexports._dumpRelayingResult = _dumpRelayingResult;","map":{"version":3,"sources":["../src/RelayClient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst ethereumjs_tx_1 = require(\"ethereumjs-tx\");\nconst ethereumjs_util_1 = require(\"ethereumjs-util\");\nconst ContractInteractor_1 = require(\"@opengsn/common/dist/ContractInteractor\");\nconst VersionsManager_1 = require(\"@opengsn/common/dist/VersionsManager\");\nconst Utils_1 = require(\"@opengsn/common/dist/Utils\");\nconst Version_1 = require(\"@opengsn/common/dist/Version\");\nconst AccountManager_1 = require(\"./AccountManager\");\nconst HttpClient_1 = require(\"@opengsn/common/dist/HttpClient\");\nconst HttpWrapper_1 = require(\"@opengsn/common/dist/HttpWrapper\");\nconst RelaySelectionManager_1 = require(\"./RelaySelectionManager\");\nconst RelayedTransactionValidator_1 = require(\"./RelayedTransactionValidator\");\nconst KnownRelaysManager_1 = require(\"./KnownRelaysManager\");\nconst ClientWinstonLogger_1 = require(\"./ClientWinstonLogger\");\nconst GSNConfigurator_1 = require(\"./GSNConfigurator\");\nconst GsnEvents_1 = require(\"./GsnEvents\");\n// forwarder requests are signed with expiration time.\nconst REQUEST_VALID_BLOCKS = 6000; // roughly a day\n// generate \"approvalData\" and \"paymasterData\" for a request.\n// both are bytes arrays. paymasterData is part of the client request.\n// approvalData is created after request is filled and signed.\nexports.EmptyDataCallback = async () => {\n    return '0x';\n};\nexports.GasPricePingFilter = (pingResponse, gsnTransactionDetails) => {\n    if (gsnTransactionDetails.gasPrice != null &&\n        parseInt(pingResponse.minGasPrice) > parseInt(gsnTransactionDetails.gasPrice)) {\n        throw new Error(`Proposed gas price: ${gsnTransactionDetails.gasPrice}; relay's MinGasPrice: ${pingResponse.minGasPrice}`);\n    }\n};\nclass RelayClient {\n    constructor(rawConstructorInput) {\n        var _a, _b, _c, _d;\n        this.emitter = new events_1.EventEmitter();\n        this.initialized = false;\n        // TODO: backwards-compatibility 102 - remove on next version bump\n        if (arguments[0] == null || arguments[0].send != null || arguments[2] != null) {\n            throw new Error('Sorry, but the constructor parameters of the RelayClient class have changed. See \"GSNUnresolvedConstructorInput\" interface for details.');\n        }\n        this.rawConstructorInput = rawConstructorInput;\n        this.logger = (_b = (_a = rawConstructorInput.overrideDependencies) === null || _a === void 0 ? void 0 : _a.logger) !== null && _b !== void 0 ? _b : ClientWinstonLogger_1.createClientLogger((_d = (_c = rawConstructorInput.config) === null || _c === void 0 ? void 0 : _c.loggerConfiguration) !== null && _d !== void 0 ? _d : GSNConfigurator_1.defaultLoggerConfiguration);\n    }\n    async init() {\n        if (this.initialized) {\n            throw new Error('init() already called');\n        }\n        this.initializingPromise = this._initInternal();\n        await this.initializingPromise;\n        this.initialized = true;\n        return this;\n    }\n    async _initInternal() {\n        this.emit(new GsnEvents_1.GsnInitEvent());\n        this.config = await this._resolveConfiguration(this.rawConstructorInput);\n        this.dependencies = await this._resolveDependencies(this.rawConstructorInput);\n    }\n    /**\n     * register a listener for GSN events\n     * @see GsnEvent and its subclasses for emitted events\n     * @param handler callback function to handle events\n     */\n    registerEventListener(handler) {\n        this.emitter.on('gsn', handler);\n    }\n    /**\n     * unregister previously registered event listener\n     * @param handler callback function to unregister\n     */\n    unregisterEventListener(handler) {\n        this.emitter.off('gsn', handler);\n    }\n    emit(event) {\n        this.emitter.emit('gsn', event);\n    }\n    /**\n     * In case Relay Server does not broadcast the signed transaction to the network,\n     * client also broadcasts the same transaction. If the transaction fails with nonce\n     * error, it indicates Relay may have signed multiple transactions with same nonce,\n     * causing a DoS attack.\n     *\n     * @param {*} transaction - actual Ethereum transaction, signed by a relay\n     */\n    async _broadcastRawTx(transaction) {\n        const rawTx = '0x' + transaction.serialize().toString('hex');\n        const txHash = '0x' + transaction.hash(true).toString('hex');\n        this.logger.info(`Broadcasting raw transaction signed by relay. TxHash: ${txHash}`);\n        try {\n            if (await this._isAlreadySubmitted(txHash)) {\n                return { hasReceipt: true };\n            }\n            // can't find the TX in the mempool. broadcast it ourselves.\n            await this.dependencies.contractInteractor.sendSignedTransaction(rawTx);\n            return { hasReceipt: true };\n        }\n        catch (broadcastError) {\n            // don't display error for the known-good cases\n            if ((broadcastError === null || broadcastError === void 0 ? void 0 : broadcastError.message.match(/the tx doesn't have the correct nonce|known transaction/)) != null) {\n                return {\n                    hasReceipt: false,\n                    wrongNonce: true,\n                    broadcastError\n                };\n            }\n            return { hasReceipt: false, broadcastError };\n        }\n    }\n    async _isAlreadySubmitted(txHash) {\n        const [txMinedReceipt, pendingBlock] = await Promise.all([\n            this.dependencies.contractInteractor.web3.eth.getTransactionReceipt(txHash),\n            // mempool transactions\n            this.dependencies.contractInteractor.web3.eth.getBlock('pending')\n        ]);\n        if (txMinedReceipt != null) {\n            return true;\n        }\n        return pendingBlock.transactions.includes(txHash);\n    }\n    async relayTransaction(gsnTransactionDetails) {\n        var _a, _b;\n        if (!this.initialized) {\n            if (this.initializingPromise == null) {\n                this._warn('suggestion: call RelayProvider.init()/RelayClient.init() in advance (to make first request faster)');\n            }\n            await this.init();\n        }\n        // TODO: should have a better strategy to decide how often to refresh known relays\n        this.emit(new GsnEvents_1.GsnRefreshRelaysEvent());\n        await this.dependencies.knownRelaysManager.refresh();\n        gsnTransactionDetails.gasPrice = (_a = gsnTransactionDetails.forceGasPrice) !== null && _a !== void 0 ? _a : await this._calculateGasPrice();\n        if (gsnTransactionDetails.gas == null) {\n            const estimated = await this.dependencies.contractInteractor.estimateGas(gsnTransactionDetails);\n            gsnTransactionDetails.gas = `0x${estimated.toString(16)}`;\n        }\n        const relaySelectionManager = await new RelaySelectionManager_1.RelaySelectionManager(gsnTransactionDetails, this.dependencies.knownRelaysManager, this.dependencies.httpClient, this.dependencies.pingFilter, this.logger, this.config).init();\n        const count = relaySelectionManager.relaysLeft().length;\n        this.emit(new GsnEvents_1.GsnDoneRefreshRelaysEvent(count));\n        if (count === 0) {\n            throw new Error('no registered relayers');\n        }\n        const relayingErrors = new Map();\n        const auditPromises = [];\n        while (true) {\n            let relayingAttempt;\n            const activeRelay = await relaySelectionManager.selectNextRelay();\n            if (activeRelay != null) {\n                this.emit(new GsnEvents_1.GsnNextRelayEvent(activeRelay.relayInfo.relayUrl));\n                relayingAttempt = await this._attemptRelay(activeRelay, gsnTransactionDetails)\n                    .catch(error => ({ error }));\n                if (relayingAttempt.auditPromise != null) {\n                    auditPromises.push(relayingAttempt.auditPromise);\n                }\n                if (relayingAttempt.transaction == null) {\n                    relayingErrors.set(activeRelay.relayInfo.relayUrl, (_b = relayingAttempt.error) !== null && _b !== void 0 ? _b : new Error('No error reason was given'));\n                    continue;\n                }\n            }\n            return {\n                transaction: relayingAttempt === null || relayingAttempt === void 0 ? void 0 : relayingAttempt.transaction,\n                relayingErrors,\n                auditPromises,\n                pingErrors: relaySelectionManager.errors\n            };\n        }\n    }\n    _warn(msg) {\n        this.logger.warn(msg);\n    }\n    async _calculateGasPrice() {\n        const pct = this.config.gasPriceFactorPercent;\n        const networkGasPrice = await this.dependencies.contractInteractor.getGasPrice();\n        let gasPrice = Math.round(parseInt(networkGasPrice) * (pct + 100) / 100);\n        if (this.config.minGasPrice != null && gasPrice < this.config.minGasPrice) {\n            gasPrice = this.config.minGasPrice;\n        }\n        return `0x${gasPrice.toString(16)}`;\n    }\n    async _attemptRelay(relayInfo, gsnTransactionDetails) {\n        this.logger.info(`attempting relay: ${JSON.stringify(relayInfo)} transaction: ${JSON.stringify(gsnTransactionDetails)}`);\n        const maxAcceptanceBudget = parseInt(relayInfo.pingResponse.maxAcceptanceBudget);\n        const httpRequest = await this._prepareRelayHttpRequest(relayInfo, gsnTransactionDetails);\n        this.emit(new GsnEvents_1.GsnValidateRequestEvent());\n        const acceptRelayCallResult = await this.dependencies.contractInteractor.validateRelayCall(maxAcceptanceBudget, httpRequest.relayRequest, httpRequest.metadata.signature, httpRequest.metadata.approvalData, this.config.maxViewableGasLimit);\n        if (!acceptRelayCallResult.paymasterAccepted) {\n            let message;\n            if (acceptRelayCallResult.reverted) {\n                message = 'local view call to \\'relayCall()\\' reverted';\n            }\n            else {\n                message = 'paymaster rejected in local view call to \\'relayCall()\\' ';\n            }\n            return { error: new Error(`${message}: ${Utils_1.decodeRevertReason(acceptRelayCallResult.returnValue)}`) };\n        }\n        let hexTransaction;\n        let transaction;\n        let auditPromise;\n        this.emit(new GsnEvents_1.GsnSendToRelayerEvent(relayInfo.relayInfo.relayUrl));\n        try {\n            hexTransaction = await this.dependencies.httpClient.relayTransaction(relayInfo.relayInfo.relayUrl, httpRequest);\n            transaction = new ethereumjs_tx_1.Transaction(hexTransaction, this.dependencies.contractInteractor.getRawTxOptions());\n            auditPromise = this.auditTransaction(hexTransaction, relayInfo.relayInfo.relayUrl)\n                .then((penalizeResponse) => {\n                if (penalizeResponse.commitTxHash != null) {\n                    const txHash = ethereumjs_util_1.bufferToHex(transaction.hash(true));\n                    this.logger.error(`The transaction with id: ${txHash} was penalized! Penalization commitment tx id: ${penalizeResponse.commitTxHash}`);\n                }\n                return penalizeResponse;\n            });\n        }\n        catch (error) {\n            if ((error === null || error === void 0 ? void 0 : error.message) == null || error.message.indexOf('timeout') !== -1) {\n                this.dependencies.knownRelaysManager.saveRelayFailure(new Date().getTime(), relayInfo.relayInfo.relayManager, relayInfo.relayInfo.relayUrl);\n            }\n            this.logger.info(`relayTransaction: ${JSON.stringify(httpRequest)}`);\n            return { error };\n        }\n        if (!this.dependencies.transactionValidator.validateRelayResponse(httpRequest, maxAcceptanceBudget, hexTransaction)) {\n            this.emit(new GsnEvents_1.GsnRelayerResponseEvent(false));\n            this.dependencies.knownRelaysManager.saveRelayFailure(new Date().getTime(), relayInfo.relayInfo.relayManager, relayInfo.relayInfo.relayUrl);\n            return {\n                auditPromise,\n                error: new Error('Returned transaction did not pass validation')\n            };\n        }\n        this.emit(new GsnEvents_1.GsnRelayerResponseEvent(true));\n        await this._broadcastRawTx(transaction);\n        return {\n            auditPromise,\n            transaction\n        };\n    }\n    async _prepareRelayHttpRequest(relayInfo, gsnTransactionDetails) {\n        var _a, _b, _c;\n        const relayHubAddress = this.dependencies.contractInteractor.getDeployment().relayHubAddress;\n        const forwarder = (_a = gsnTransactionDetails.forwarder) !== null && _a !== void 0 ? _a : this.dependencies.contractInteractor.getDeployment().forwarderAddress;\n        const paymaster = (_b = gsnTransactionDetails.paymaster) !== null && _b !== void 0 ? _b : this.dependencies.contractInteractor.getDeployment().paymasterAddress;\n        if (relayHubAddress == null || paymaster == null || forwarder == null) {\n            throw new Error('Contract addresses are not initialized!');\n        }\n        // valid that many blocks into the future.\n        const validUntilPromise = this.dependencies.contractInteractor.getBlockNumber()\n            .then((num) => (num + REQUEST_VALID_BLOCKS).toString());\n        const senderNonce = await this.dependencies.contractInteractor.getSenderNonce(gsnTransactionDetails.from, forwarder);\n        const relayWorker = relayInfo.pingResponse.relayWorkerAddress;\n        const gasPriceHex = gsnTransactionDetails.gasPrice;\n        const gasLimitHex = gsnTransactionDetails.gas;\n        if (gasPriceHex == null || gasLimitHex == null) {\n            throw new Error('RelayClient internal exception. Gas price or gas limit still not calculated. Cannot happen.');\n        }\n        if (gasPriceHex.indexOf('0x') !== 0) {\n            throw new Error(`Invalid gasPrice hex string: ${gasPriceHex}`);\n        }\n        if (gasLimitHex.indexOf('0x') !== 0) {\n            throw new Error(`Invalid gasLimit hex string: ${gasLimitHex}`);\n        }\n        const gasLimit = parseInt(gasLimitHex, 16).toString();\n        const gasPrice = parseInt(gasPriceHex, 16).toString();\n        const value = (_c = gsnTransactionDetails.value) !== null && _c !== void 0 ? _c : '0';\n        const relayRequest = {\n            request: {\n                to: gsnTransactionDetails.to,\n                data: gsnTransactionDetails.data,\n                from: gsnTransactionDetails.from,\n                value: value,\n                nonce: senderNonce,\n                gas: gasLimit,\n                validUntil: await validUntilPromise\n            },\n            relayData: {\n                pctRelayFee: relayInfo.relayInfo.pctRelayFee,\n                baseRelayFee: relayInfo.relayInfo.baseRelayFee,\n                gasPrice,\n                paymaster,\n                paymasterData: '',\n                clientId: this.config.clientId,\n                forwarder,\n                relayWorker\n            }\n        };\n        // put paymasterData into struct before signing\n        relayRequest.relayData.paymasterData = await this.dependencies.asyncPaymasterData(relayRequest);\n        this.emit(new GsnEvents_1.GsnSignRequestEvent());\n        const signature = await this.dependencies.accountManager.sign(relayRequest);\n        const approvalData = await this.dependencies.asyncApprovalData(relayRequest);\n        // max nonce is not signed, as contracts cannot access addresses' nonces.\n        const transactionCount = await this.dependencies.contractInteractor.getTransactionCount(relayWorker);\n        const relayMaxNonce = transactionCount + this.config.maxRelayNonceGap;\n        // TODO: the server accepts a flat object, and that is why this code looks like shit.\n        //  Must teach server to accept correct types\n        const metadata = {\n            relayHubAddress,\n            signature,\n            approvalData,\n            relayMaxNonce\n        };\n        const httpRequest = {\n            relayRequest,\n            metadata\n        };\n        this.logger.info(`Created HTTP relay request: ${JSON.stringify(httpRequest)}`);\n        return httpRequest;\n    }\n    newAccount() {\n        this._verifyInitialized();\n        return this.dependencies.accountManager.newAccount();\n    }\n    addAccount(privateKey) {\n        this._verifyInitialized();\n        this.dependencies.accountManager.addAccount(privateKey);\n    }\n    _verifyInitialized() {\n        if (!this.initialized) {\n            throw new Error('not initialized. must call RelayClient.init()');\n        }\n    }\n    async auditTransaction(hexTransaction, sourceRelayUrl) {\n        const auditors = this.dependencies.knownRelaysManager.getAuditors([sourceRelayUrl]);\n        let failedAuditorsCount = 0;\n        for (const auditor of auditors) {\n            try {\n                const penalizeResponse = await this.dependencies.httpClient.auditTransaction(auditor, hexTransaction);\n                if (penalizeResponse.commitTxHash != null) {\n                    return penalizeResponse;\n                }\n            }\n            catch (e) {\n                failedAuditorsCount++;\n                this.logger.info(`Audit call failed for relay at URL: ${auditor}. Failed audit calls: ${failedAuditorsCount}/${auditors.length}`);\n            }\n        }\n        if (auditors.length === failedAuditorsCount && failedAuditorsCount !== 0) {\n            this.logger.error('All auditors failed!');\n        }\n        return {\n            message: `Transaction was not audited. Failed audit calls: ${failedAuditorsCount}/${auditors.length}`\n        };\n    }\n    getUnderlyingProvider() {\n        return this.rawConstructorInput.provider;\n    }\n    async _resolveConfiguration({ provider, config = {} }) {\n        var _a, _b;\n        const isMetamask = provider.isMetaMask;\n        // provide defaults valid for metamask (unless explicitly specified values)\n        const methodSuffix = (_a = config.methodSuffix) !== null && _a !== void 0 ? _a : (isMetamask ? '_v4' : GSNConfigurator_1.defaultGsnConfig.methodSuffix);\n        const jsonStringifyRequest = (_b = config.jsonStringifyRequest) !== null && _b !== void 0 ? _b : (isMetamask ? true : GSNConfigurator_1.defaultGsnConfig.jsonStringifyRequest);\n        const resolvedConfig = {\n            methodSuffix,\n            jsonStringifyRequest\n        };\n        return Object.assign(Object.assign(Object.assign({}, GSNConfigurator_1.defaultGsnConfig), resolvedConfig), config);\n    }\n    async _resolveDependencies({ provider, config = {}, overrideDependencies = {} }) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n        const versionManager = new VersionsManager_1.VersionsManager(Version_1.gsnRuntimeVersion, (_a = config.requiredVersionRange) !== null && _a !== void 0 ? _a : Version_1.gsnRequiredVersion);\n        const contractInteractor = (_b = overrideDependencies === null || overrideDependencies === void 0 ? void 0 : overrideDependencies.contractInteractor) !== null && _b !== void 0 ? _b : await new ContractInteractor_1.ContractInteractor({\n            provider,\n            versionManager,\n            logger: this.logger,\n            maxPageSize: this.config.pastEventsQueryMaxPageSize,\n            deployment: { paymasterAddress: config === null || config === void 0 ? void 0 : config.paymasterAddress }\n        }).init();\n        const accountManager = (_c = overrideDependencies === null || overrideDependencies === void 0 ? void 0 : overrideDependencies.accountManager) !== null && _c !== void 0 ? _c : new AccountManager_1.AccountManager(provider, contractInteractor.chainId, this.config);\n        const httpClient = (_d = overrideDependencies === null || overrideDependencies === void 0 ? void 0 : overrideDependencies.httpClient) !== null && _d !== void 0 ? _d : new HttpClient_1.HttpClient(new HttpWrapper_1.HttpWrapper(), this.logger);\n        const pingFilter = (_e = overrideDependencies === null || overrideDependencies === void 0 ? void 0 : overrideDependencies.pingFilter) !== null && _e !== void 0 ? _e : exports.GasPricePingFilter;\n        const relayFilter = (_f = overrideDependencies === null || overrideDependencies === void 0 ? void 0 : overrideDependencies.relayFilter) !== null && _f !== void 0 ? _f : KnownRelaysManager_1.EmptyFilter;\n        const asyncApprovalData = (_g = overrideDependencies === null || overrideDependencies === void 0 ? void 0 : overrideDependencies.asyncApprovalData) !== null && _g !== void 0 ? _g : exports.EmptyDataCallback;\n        const asyncPaymasterData = (_h = overrideDependencies === null || overrideDependencies === void 0 ? void 0 : overrideDependencies.asyncPaymasterData) !== null && _h !== void 0 ? _h : exports.EmptyDataCallback;\n        const scoreCalculator = (_j = overrideDependencies === null || overrideDependencies === void 0 ? void 0 : overrideDependencies.scoreCalculator) !== null && _j !== void 0 ? _j : KnownRelaysManager_1.DefaultRelayScore;\n        const knownRelaysManager = (_k = overrideDependencies === null || overrideDependencies === void 0 ? void 0 : overrideDependencies.knownRelaysManager) !== null && _k !== void 0 ? _k : new KnownRelaysManager_1.KnownRelaysManager(contractInteractor, this.logger, this.config, relayFilter);\n        const transactionValidator = (_l = overrideDependencies === null || overrideDependencies === void 0 ? void 0 : overrideDependencies.transactionValidator) !== null && _l !== void 0 ? _l : new RelayedTransactionValidator_1.RelayedTransactionValidator(contractInteractor, this.logger, this.config);\n        return {\n            logger: this.logger,\n            httpClient,\n            contractInteractor,\n            knownRelaysManager,\n            accountManager,\n            transactionValidator,\n            pingFilter,\n            relayFilter,\n            asyncApprovalData,\n            asyncPaymasterData,\n            scoreCalculator\n        };\n    }\n}\nexports.RelayClient = RelayClient;\nfunction _dumpRelayingResult(relayingResult) {\n    let str = '';\n    if (relayingResult.pingErrors.size > 0) {\n        str += `Ping errors (${relayingResult.pingErrors.size}):`;\n        Array.from(relayingResult.pingErrors.keys()).forEach(e => {\n            var _a, _b;\n            const err = relayingResult.pingErrors.get(e);\n            const error = (_b = (_a = err === null || err === void 0 ? void 0 : err.message) !== null && _a !== void 0 ? _a : err === null || err === void 0 ? void 0 : err.toString()) !== null && _b !== void 0 ? _b : '';\n            str += `\\n${e} => ${error}\\n`;\n        });\n    }\n    if (relayingResult.relayingErrors.size > 0) {\n        str += `Relaying errors (${relayingResult.relayingErrors.size}):\\n`;\n        Array.from(relayingResult.relayingErrors.keys()).forEach(e => {\n            var _a, _b;\n            const err = relayingResult.relayingErrors.get(e);\n            const error = (_b = (_a = err === null || err === void 0 ? void 0 : err.message) !== null && _a !== void 0 ? _a : err === null || err === void 0 ? void 0 : err.toString()) !== null && _b !== void 0 ? _b : '';\n            str += `${e} => ${error}`;\n        });\n    }\n    return str;\n}\nexports._dumpRelayingResult = _dumpRelayingResult;\n//# sourceMappingURL=RelayClient.js.map"]},"metadata":{},"sourceType":"script"}