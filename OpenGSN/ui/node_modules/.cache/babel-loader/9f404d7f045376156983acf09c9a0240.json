{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst Utils_1 = require(\"@opengsn/common/dist/Utils\");\n\nconst GSNContractsDataTypes_1 = require(\"@opengsn/common/dist/types/GSNContractsDataTypes\");\n\nexports.EmptyFilter = () => {\n  return true;\n};\n/**\n * Basic score is reversed transaction fee, higher is better.\n * Relays that failed to respond recently will be downgraded for some period of time.\n */\n\n\nexports.DefaultRelayScore = async function (relay, txDetails, failures) {\n  var _a, _b;\n\n  const gasLimit = parseInt((_a = txDetails.gas) !== null && _a !== void 0 ? _a : '0');\n  const gasPrice = parseInt((_b = txDetails.gasPrice) !== null && _b !== void 0 ? _b : '0');\n  const pctFee = parseInt(relay.pctRelayFee);\n  const baseFee = parseInt(relay.baseRelayFee);\n  const transactionCost = baseFee + gasLimit * gasPrice * (100 + pctFee) / 100;\n  let score = Math.max(Number.MAX_SAFE_INTEGER - transactionCost, 0);\n  score = score * Math.pow(0.9, failures.length);\n  return score;\n};\n\nclass KnownRelaysManager {\n  constructor(contractInteractor, logger, config, relayFilter, scoreCalculator) {\n    this.latestScannedBlock = 0;\n    this.relayFailures = new Map();\n    this.preferredRelayers = [];\n    this.allRelayers = [];\n    this.config = config;\n    this.logger = logger;\n    this.relayFilter = relayFilter !== null && relayFilter !== void 0 ? relayFilter : exports.EmptyFilter;\n    this.scoreCalculator = scoreCalculator !== null && scoreCalculator !== void 0 ? scoreCalculator : exports.DefaultRelayScore;\n    this.contractInteractor = contractInteractor;\n  }\n\n  async refresh() {\n    this._refreshFailures();\n\n    const recentlyActiveRelayManagers = await this._fetchRecentlyActiveRelayManagers();\n    this.preferredRelayers = this.config.preferredRelays.map(relayUrl => {\n      return {\n        relayUrl\n      };\n    });\n    this.allRelayers = await this.getRelayInfoForManagers(recentlyActiveRelayManagers);\n  }\n\n  async getRelayInfoForManagers(relayManagers) {\n    // As 'topics' are used as 'filter', having an empty set results in querying all register events.\n    if (relayManagers.size === 0) {\n      return [];\n    }\n\n    const toBlock = await this.contractInteractor.getBlockNumber();\n    const fromBlock = Math.max(0, toBlock - this.config.relayRegistrationLookupBlocks);\n    const topics = Utils_1.addresses2topics(Array.from(relayManagers));\n    const relayServerRegisteredEvents = await this.contractInteractor.getPastEventsForHub(topics, {\n      fromBlock\n    }, [GSNContractsDataTypes_1.RelayServerRegistered]);\n    const relayManagerExitEvents = await this.contractInteractor.getPastEventsForStakeManager([GSNContractsDataTypes_1.StakeUnlocked, GSNContractsDataTypes_1.HubUnauthorized, GSNContractsDataTypes_1.StakePenalized], topics, {\n      fromBlock\n    });\n    this.logger.info(`== getRelayInfoForManagers: found ${relayServerRegisteredEvents.length} unique RelayServerRegistered events`);\n\n    if (relayServerRegisteredEvents.length === 0) {\n      this.logger.error(`Did not find any RelayServerRegistered Event for any of ${relayManagers.size} relay managers! {fromBlock: ${fromBlock}, toBlock: ${toBlock}}`);\n    }\n\n    const mergedEvents = [...relayManagerExitEvents, ...relayServerRegisteredEvents].sort((a, b) => {\n      const blockNumberA = a.blockNumber;\n      const blockNumberB = b.blockNumber;\n      const transactionIndexA = a.transactionIndex;\n      const transactionIndexB = b.transactionIndex;\n\n      if (blockNumberA === blockNumberB) {\n        return transactionIndexA - transactionIndexB;\n      }\n\n      return blockNumberA - blockNumberB;\n    });\n    const activeRelays = new Map();\n    mergedEvents.forEach(event => {\n      const args = event.returnValues;\n\n      if (event.event === GSNContractsDataTypes_1.RelayServerRegistered) {\n        activeRelays.set(args.relayManager, args);\n      } else {\n        activeRelays.delete(args.relayManager);\n      }\n    });\n    const origRelays = Array.from(activeRelays.values());\n    return origRelays.filter(this.relayFilter);\n  }\n\n  async _fetchRecentlyActiveRelayManagers() {\n    const toBlock = await this.contractInteractor.getBlockNumber();\n    const fromBlock = Math.max(0, toBlock - this.config.relayLookupWindowBlocks);\n    const relayEvents = await this.contractInteractor.getPastEventsForHub([], {\n      fromBlock,\n      toBlock\n    }, undefined);\n    this.logger.info(`fetchRelaysAdded: found ${relayEvents.length} events`);\n    const foundRelayManagers = new Set();\n    relayEvents.forEach(event => {\n      // TODO: remove relay managers who are not staked\n      // if (event.event === 'RelayRemoved') {\n      //   foundRelays.delete(event.returnValues.relay)\n      // } else {\n      foundRelayManagers.add(event.returnValues.relayManager);\n    });\n    this.logger.info(`fetchRelaysAdded: found unique relays: ${JSON.stringify(Array.from(foundRelayManagers.values()))}`);\n    this.latestScannedBlock = toBlock;\n    return foundRelayManagers;\n  }\n\n  _refreshFailures() {\n    const newMap = new Map();\n    this.relayFailures.forEach((value, key) => {\n      newMap.set(key, value.filter(failure => {\n        const elapsed = (new Date().getTime() - failure.lastErrorTime) / 1000;\n        return elapsed < this.config.relayTimeoutGrace;\n      }));\n    });\n    this.relayFailures = newMap;\n  }\n\n  async getRelaysSortedForTransaction(gsnTransactionDetails) {\n    const sortedRelays = []; // preferred relays are copied as-is, unsorted (we don't have any info about them anyway to sort)\n\n    sortedRelays[0] = Array.from(this.preferredRelayers);\n    sortedRelays[1] = await this._sortRelaysInternal(gsnTransactionDetails, this.allRelayers);\n    return sortedRelays;\n  }\n\n  getAuditors(excludeUrls) {\n    const indexes = [];\n    const auditors = [];\n    const flatRelayers = [...this.preferredRelayers, ...this.allRelayers].map(it => it.relayUrl).filter(it => !excludeUrls.includes(it)).filter((value, index, self) => {\n      return self.indexOf(value) === index;\n    });\n\n    if (flatRelayers.length <= this.config.auditorsCount) {\n      if (flatRelayers.length < this.config.auditorsCount) {\n        this.logger.warn(`Not enough auditors: request ${this.config.auditorsCount} but only have ${flatRelayers.length}`);\n      }\n\n      return flatRelayers;\n    }\n\n    do {\n      const index = Math.floor(Math.random() * flatRelayers.length);\n\n      if (!indexes.includes(index)) {\n        auditors.push(flatRelayers[index]);\n        indexes.push(index);\n      }\n    } while (auditors.length < this.config.auditorsCount);\n\n    return auditors;\n  }\n\n  async _sortRelaysInternal(gsnTransactionDetails, activeRelays) {\n    var _a;\n\n    const scores = new Map();\n\n    for (const activeRelay of activeRelays) {\n      let score = 0;\n\n      if (GSNContractsDataTypes_1.isInfoFromEvent(activeRelay)) {\n        const eventInfo = activeRelay;\n        score = await this.scoreCalculator(eventInfo, gsnTransactionDetails, (_a = this.relayFailures.get(activeRelay.relayUrl)) !== null && _a !== void 0 ? _a : []);\n        scores.set(eventInfo.relayManager, score);\n      }\n    }\n\n    return Array.from(activeRelays.values()).filter(GSNContractsDataTypes_1.isInfoFromEvent).map(value => value).sort((a, b) => {\n      var _a, _b;\n\n      const aScore = (_a = scores.get(a.relayManager)) !== null && _a !== void 0 ? _a : 0;\n      const bScore = (_b = scores.get(b.relayManager)) !== null && _b !== void 0 ? _b : 0;\n      return bScore - aScore;\n    });\n  }\n\n  saveRelayFailure(lastErrorTime, relayManager, relayUrl) {\n    const relayFailures = this.relayFailures.get(relayUrl);\n    const newFailureInfo = {\n      lastErrorTime,\n      relayManager,\n      relayUrl\n    };\n\n    if (relayFailures == null) {\n      this.relayFailures.set(relayUrl, [newFailureInfo]);\n    } else {\n      relayFailures.push(newFailureInfo);\n    }\n  }\n\n}\n\nexports.KnownRelaysManager = KnownRelaysManager;","map":{"version":3,"sources":["../src/KnownRelaysManager.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Utils_1 = require(\"@opengsn/common/dist/Utils\");\nconst GSNContractsDataTypes_1 = require(\"@opengsn/common/dist/types/GSNContractsDataTypes\");\nexports.EmptyFilter = () => {\n    return true;\n};\n/**\n * Basic score is reversed transaction fee, higher is better.\n * Relays that failed to respond recently will be downgraded for some period of time.\n */\nexports.DefaultRelayScore = async function (relay, txDetails, failures) {\n    var _a, _b;\n    const gasLimit = parseInt((_a = txDetails.gas) !== null && _a !== void 0 ? _a : '0');\n    const gasPrice = parseInt((_b = txDetails.gasPrice) !== null && _b !== void 0 ? _b : '0');\n    const pctFee = parseInt(relay.pctRelayFee);\n    const baseFee = parseInt(relay.baseRelayFee);\n    const transactionCost = baseFee + (gasLimit * gasPrice * (100 + pctFee)) / 100;\n    let score = Math.max(Number.MAX_SAFE_INTEGER - transactionCost, 0);\n    score = score * Math.pow(0.9, failures.length);\n    return score;\n};\nclass KnownRelaysManager {\n    constructor(contractInteractor, logger, config, relayFilter, scoreCalculator) {\n        this.latestScannedBlock = 0;\n        this.relayFailures = new Map();\n        this.preferredRelayers = [];\n        this.allRelayers = [];\n        this.config = config;\n        this.logger = logger;\n        this.relayFilter = relayFilter !== null && relayFilter !== void 0 ? relayFilter : exports.EmptyFilter;\n        this.scoreCalculator = scoreCalculator !== null && scoreCalculator !== void 0 ? scoreCalculator : exports.DefaultRelayScore;\n        this.contractInteractor = contractInteractor;\n    }\n    async refresh() {\n        this._refreshFailures();\n        const recentlyActiveRelayManagers = await this._fetchRecentlyActiveRelayManagers();\n        this.preferredRelayers = this.config.preferredRelays.map(relayUrl => { return { relayUrl }; });\n        this.allRelayers = await this.getRelayInfoForManagers(recentlyActiveRelayManagers);\n    }\n    async getRelayInfoForManagers(relayManagers) {\n        // As 'topics' are used as 'filter', having an empty set results in querying all register events.\n        if (relayManagers.size === 0) {\n            return [];\n        }\n        const toBlock = await this.contractInteractor.getBlockNumber();\n        const fromBlock = Math.max(0, toBlock - this.config.relayRegistrationLookupBlocks);\n        const topics = Utils_1.addresses2topics(Array.from(relayManagers));\n        const relayServerRegisteredEvents = await this.contractInteractor.getPastEventsForHub(topics, { fromBlock }, [GSNContractsDataTypes_1.RelayServerRegistered]);\n        const relayManagerExitEvents = await this.contractInteractor.getPastEventsForStakeManager([GSNContractsDataTypes_1.StakeUnlocked, GSNContractsDataTypes_1.HubUnauthorized, GSNContractsDataTypes_1.StakePenalized], topics, { fromBlock });\n        this.logger.info(`== getRelayInfoForManagers: found ${relayServerRegisteredEvents.length} unique RelayServerRegistered events`);\n        if (relayServerRegisteredEvents.length === 0) {\n            this.logger.error(`Did not find any RelayServerRegistered Event for any of ${relayManagers.size} relay managers! {fromBlock: ${fromBlock}, toBlock: ${toBlock}}`);\n        }\n        const mergedEvents = [...relayManagerExitEvents, ...relayServerRegisteredEvents].sort((a, b) => {\n            const blockNumberA = a.blockNumber;\n            const blockNumberB = b.blockNumber;\n            const transactionIndexA = a.transactionIndex;\n            const transactionIndexB = b.transactionIndex;\n            if (blockNumberA === blockNumberB) {\n                return transactionIndexA - transactionIndexB;\n            }\n            return blockNumberA - blockNumberB;\n        });\n        const activeRelays = new Map();\n        mergedEvents.forEach(event => {\n            const args = event.returnValues;\n            if (event.event === GSNContractsDataTypes_1.RelayServerRegistered) {\n                activeRelays.set(args.relayManager, args);\n            }\n            else {\n                activeRelays.delete(args.relayManager);\n            }\n        });\n        const origRelays = Array.from(activeRelays.values());\n        return origRelays.filter(this.relayFilter);\n    }\n    async _fetchRecentlyActiveRelayManagers() {\n        const toBlock = await this.contractInteractor.getBlockNumber();\n        const fromBlock = Math.max(0, toBlock - this.config.relayLookupWindowBlocks);\n        const relayEvents = await this.contractInteractor.getPastEventsForHub([], {\n            fromBlock,\n            toBlock\n        }, undefined);\n        this.logger.info(`fetchRelaysAdded: found ${relayEvents.length} events`);\n        const foundRelayManagers = new Set();\n        relayEvents.forEach((event) => {\n            // TODO: remove relay managers who are not staked\n            // if (event.event === 'RelayRemoved') {\n            //   foundRelays.delete(event.returnValues.relay)\n            // } else {\n            foundRelayManagers.add(event.returnValues.relayManager);\n        });\n        this.logger.info(`fetchRelaysAdded: found unique relays: ${JSON.stringify(Array.from(foundRelayManagers.values()))}`);\n        this.latestScannedBlock = toBlock;\n        return foundRelayManagers;\n    }\n    _refreshFailures() {\n        const newMap = new Map();\n        this.relayFailures.forEach((value, key) => {\n            newMap.set(key, value.filter(failure => {\n                const elapsed = (new Date().getTime() - failure.lastErrorTime) / 1000;\n                return elapsed < this.config.relayTimeoutGrace;\n            }));\n        });\n        this.relayFailures = newMap;\n    }\n    async getRelaysSortedForTransaction(gsnTransactionDetails) {\n        const sortedRelays = [];\n        // preferred relays are copied as-is, unsorted (we don't have any info about them anyway to sort)\n        sortedRelays[0] = Array.from(this.preferredRelayers);\n        sortedRelays[1] = await this._sortRelaysInternal(gsnTransactionDetails, this.allRelayers);\n        return sortedRelays;\n    }\n    getAuditors(excludeUrls) {\n        const indexes = [];\n        const auditors = [];\n        const flatRelayers = [...this.preferredRelayers, ...this.allRelayers]\n            .map(it => it.relayUrl)\n            .filter(it => !excludeUrls.includes(it))\n            .filter((value, index, self) => {\n            return self.indexOf(value) === index;\n        });\n        if (flatRelayers.length <= this.config.auditorsCount) {\n            if (flatRelayers.length < this.config.auditorsCount) {\n                this.logger.warn(`Not enough auditors: request ${this.config.auditorsCount} but only have ${flatRelayers.length}`);\n            }\n            return flatRelayers;\n        }\n        do {\n            const index = Math.floor(Math.random() * flatRelayers.length);\n            if (!indexes.includes(index)) {\n                auditors.push(flatRelayers[index]);\n                indexes.push(index);\n            }\n        } while (auditors.length < this.config.auditorsCount);\n        return auditors;\n    }\n    async _sortRelaysInternal(gsnTransactionDetails, activeRelays) {\n        var _a;\n        const scores = new Map();\n        for (const activeRelay of activeRelays) {\n            let score = 0;\n            if (GSNContractsDataTypes_1.isInfoFromEvent(activeRelay)) {\n                const eventInfo = activeRelay;\n                score = await this.scoreCalculator(eventInfo, gsnTransactionDetails, (_a = this.relayFailures.get(activeRelay.relayUrl)) !== null && _a !== void 0 ? _a : []);\n                scores.set(eventInfo.relayManager, score);\n            }\n        }\n        return Array\n            .from(activeRelays.values())\n            .filter(GSNContractsDataTypes_1.isInfoFromEvent)\n            .map(value => value)\n            .sort((a, b) => {\n            var _a, _b;\n            const aScore = (_a = scores.get(a.relayManager)) !== null && _a !== void 0 ? _a : 0;\n            const bScore = (_b = scores.get(b.relayManager)) !== null && _b !== void 0 ? _b : 0;\n            return bScore - aScore;\n        });\n    }\n    saveRelayFailure(lastErrorTime, relayManager, relayUrl) {\n        const relayFailures = this.relayFailures.get(relayUrl);\n        const newFailureInfo = {\n            lastErrorTime,\n            relayManager,\n            relayUrl\n        };\n        if (relayFailures == null) {\n            this.relayFailures.set(relayUrl, [newFailureInfo]);\n        }\n        else {\n            relayFailures.push(newFailureInfo);\n        }\n    }\n}\nexports.KnownRelaysManager = KnownRelaysManager;\n//# sourceMappingURL=KnownRelaysManager.js.map"]},"metadata":{},"sourceType":"script"}