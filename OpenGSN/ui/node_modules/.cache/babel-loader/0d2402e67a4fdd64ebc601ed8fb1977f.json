{"ast":null,"code":"'use strict';\n/*\r\n * Displays a helpful message and the source of\r\n * the format when it is invalid.\r\n */\n\nclass InvalidFormatError extends Error {\n  constructor(formatFn) {\n    super(`Format functions must be synchronous taking a two arguments: (info, opts)\nFound: ${formatFn.toString().split('\\n')[0]}\\n`);\n    Error.captureStackTrace(this, InvalidFormatError);\n  }\n\n}\n/*\r\n * function format (formatFn)\r\n * Returns a create function for the `formatFn`.\r\n */\n\n\nmodule.exports = formatFn => {\n  if (formatFn.length > 2) {\n    throw new InvalidFormatError(formatFn);\n  }\n  /*\r\n   * function Format (options)\r\n   * Base prototype which calls a `_format`\r\n   * function and pushes the result.\r\n   */\n\n\n  function Format() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.options = options;\n  }\n\n  Format.prototype.transform = formatFn; //\n  // Create a function which returns new instances of\n  // FormatWrap for simple syntax like:\n  //\n  // require('winston').formats.json();\n  //\n\n  function createFormatWrap(opts) {\n    return new Format(opts);\n  } //\n  // Expose the FormatWrap through the create function\n  // for testability.\n  //\n\n\n  createFormatWrap.Format = Format;\n  return createFormatWrap;\n};","map":{"version":3,"sources":["C:/Users/nomif/Desktop/Programming/Blockchain/ethereum-gasless-transactions/OpenGSN/node_modules/logform/format.js"],"names":["InvalidFormatError","Error","constructor","formatFn","toString","split","captureStackTrace","module","exports","length","Format","options","prototype","transform","createFormatWrap","opts"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;;AACA,MAAMA,kBAAN,SAAiCC,KAAjC,CAAuC;AACrCC,EAAAA,WAAW,CAACC,QAAD,EAAW;AACpB,UAAO;AACX,SAASA,QAAQ,CAACC,QAAT,GAAoBC,KAApB,CAA0B,IAA1B,EAAgC,CAAhC,CAAmC,IADxC;AAGAJ,IAAAA,KAAK,CAACK,iBAAN,CAAwB,IAAxB,EAA8BN,kBAA9B;AACD;;AANoC;AASvC;AACA;AACA;AACA;;;AACAO,MAAM,CAACC,OAAP,GAAiBL,QAAQ,IAAI;AAC3B,MAAIA,QAAQ,CAACM,MAAT,GAAkB,CAAtB,EAAyB;AACvB,UAAM,IAAIT,kBAAJ,CAAuBG,QAAvB,CAAN;AACD;AAED;AACF;AACA;AACA;AACA;;;AACE,WAASO,MAAT,GAA8B;AAAA,QAAdC,OAAc,uEAAJ,EAAI;AAC5B,SAAKA,OAAL,GAAeA,OAAf;AACD;;AAEDD,EAAAA,MAAM,CAACE,SAAP,CAAiBC,SAAjB,GAA6BV,QAA7B,CAd2B,CAgB3B;AACA;AACA;AACA;AACA;AACA;;AACA,WAASW,gBAAT,CAA0BC,IAA1B,EAAgC;AAC9B,WAAO,IAAIL,MAAJ,CAAWK,IAAX,CAAP;AACD,GAxB0B,CA0B3B;AACA;AACA;AACA;;;AACAD,EAAAA,gBAAgB,CAACJ,MAAjB,GAA0BA,MAA1B;AACA,SAAOI,gBAAP;AACD,CAhCD","sourcesContent":["'use strict';\r\n\r\n/*\r\n * Displays a helpful message and the source of\r\n * the format when it is invalid.\r\n */\r\nclass InvalidFormatError extends Error {\r\n  constructor(formatFn) {\r\n    super(`Format functions must be synchronous taking a two arguments: (info, opts)\r\nFound: ${formatFn.toString().split('\\n')[0]}\\n`);\r\n\r\n    Error.captureStackTrace(this, InvalidFormatError);\r\n  }\r\n}\r\n\r\n/*\r\n * function format (formatFn)\r\n * Returns a create function for the `formatFn`.\r\n */\r\nmodule.exports = formatFn => {\r\n  if (formatFn.length > 2) {\r\n    throw new InvalidFormatError(formatFn);\r\n  }\r\n\r\n  /*\r\n   * function Format (options)\r\n   * Base prototype which calls a `_format`\r\n   * function and pushes the result.\r\n   */\r\n  function Format(options = {}) {\r\n    this.options = options;\r\n  }\r\n\r\n  Format.prototype.transform = formatFn;\r\n\r\n  //\r\n  // Create a function which returns new instances of\r\n  // FormatWrap for simple syntax like:\r\n  //\r\n  // require('winston').formats.json();\r\n  //\r\n  function createFormatWrap(opts) {\r\n    return new Format(opts);\r\n  }\r\n\r\n  //\r\n  // Expose the FormatWrap through the create function\r\n  // for testability.\r\n  //\r\n  createFormatWrap.Format = Format;\r\n  return createFormatWrap;\r\n};\r\n"]},"metadata":{},"sourceType":"script"}