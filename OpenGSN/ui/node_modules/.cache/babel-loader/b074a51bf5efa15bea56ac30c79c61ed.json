{"ast":null,"code":"const {\n  sha3,\n  BN\n} = require(\"web3-utils\");\n\nconst abiCoder = require(\"web3-eth-abi\");\n\nconst state = {\n  savedABIs: [],\n  methodIDs: {},\n  keepNonDecodedLogs: false\n};\n\nfunction _getABIs() {\n  return state.savedABIs;\n}\n\nfunction _typeToString(input) {\n  if (input.type === \"tuple\") {\n    return \"(\" + input.components.map(_typeToString).join(\",\") + \")\";\n  }\n\n  return input.type;\n}\n\nfunction _addABI(abiArray) {\n  if (Array.isArray(abiArray)) {\n    // Iterate new abi to generate method id\"s\n    abiArray.map(function (abi) {\n      if (abi.name) {\n        const signature = sha3(abi.name + \"(\" + abi.inputs.map(_typeToString).join(\",\") + \")\");\n\n        if (abi.type === \"event\") {\n          state.methodIDs[signature.slice(2)] = abi;\n        } else {\n          state.methodIDs[signature.slice(2, 10)] = abi;\n        }\n      }\n    });\n    state.savedABIs = state.savedABIs.concat(abiArray);\n  } else {\n    throw new Error(\"Expected ABI array, got \" + typeof abiArray);\n  }\n}\n\nfunction _removeABI(abiArray) {\n  if (Array.isArray(abiArray)) {\n    // Iterate new abi to generate method id\"s\n    abiArray.map(function (abi) {\n      if (abi.name) {\n        const signature = sha3(abi.name + \"(\" + abi.inputs.map(function (input) {\n          return input.type;\n        }).join(\",\") + \")\");\n\n        if (abi.type === \"event\") {\n          if (state.methodIDs[signature.slice(2)]) {\n            delete state.methodIDs[signature.slice(2)];\n          }\n        } else {\n          if (state.methodIDs[signature.slice(2, 10)]) {\n            delete state.methodIDs[signature.slice(2, 10)];\n          }\n        }\n      }\n    });\n  } else {\n    throw new Error(\"Expected ABI array, got \" + typeof abiArray);\n  }\n}\n\nfunction _getMethodIDs() {\n  return state.methodIDs;\n}\n\nfunction _decodeMethod(data) {\n  const methodID = data.slice(2, 10);\n  const abiItem = state.methodIDs[methodID];\n\n  if (abiItem) {\n    let decoded = abiCoder.decodeParameters(abiItem.inputs, data.slice(10));\n    let retData = {\n      name: abiItem.name,\n      params: []\n    };\n\n    for (let i = 0; i < decoded.__length__; i++) {\n      let param = decoded[i];\n      let parsedParam = param;\n      const isUint = abiItem.inputs[i].type.indexOf(\"uint\") === 0;\n      const isInt = abiItem.inputs[i].type.indexOf(\"int\") === 0;\n      const isAddress = abiItem.inputs[i].type.indexOf(\"address\") === 0;\n\n      if (isUint || isInt) {\n        const isArray = Array.isArray(param);\n\n        if (isArray) {\n          parsedParam = param.map(val => new BN(val).toString());\n        } else {\n          parsedParam = new BN(param).toString();\n        }\n      } // Addresses returned by web3 are randomly cased so we need to standardize and lowercase all\n\n\n      if (isAddress) {\n        const isArray = Array.isArray(param);\n\n        if (isArray) {\n          parsedParam = param.map(_ => _.toLowerCase());\n        } else {\n          parsedParam = param.toLowerCase();\n        }\n      }\n\n      retData.params.push({\n        name: abiItem.inputs[i].name,\n        value: parsedParam,\n        type: abiItem.inputs[i].type\n      });\n    }\n\n    return retData;\n  }\n}\n\nfunction _decodeLogs(logs) {\n  return logs.filter(log => log.topics.length > 0).map(logItem => {\n    const methodID = logItem.topics[0].slice(2);\n    const method = state.methodIDs[methodID];\n\n    if (method) {\n      const logData = logItem.data;\n      let decodedParams = [];\n      let dataIndex = 0;\n      let topicsIndex = 1;\n      let dataTypes = [];\n      method.inputs.map(function (input) {\n        if (!input.indexed) {\n          dataTypes.push(input.type);\n        }\n      });\n      const decodedData = abiCoder.decodeParameters(dataTypes, logData.slice(2)); // Loop topic and data to get the params\n\n      method.inputs.map(function (param) {\n        let decodedP = {\n          name: param.name,\n          type: param.type\n        };\n\n        if (param.indexed) {\n          decodedP.value = logItem.topics[topicsIndex];\n          topicsIndex++;\n        } else {\n          decodedP.value = decodedData[dataIndex];\n          dataIndex++;\n        }\n\n        if (param.type === \"address\") {\n          decodedP.value = decodedP.value.toLowerCase(); // 42 because len(0x) + 40\n\n          if (decodedP.value.length > 42) {\n            let toRemove = decodedP.value.length - 42;\n            let temp = decodedP.value.split(\"\");\n            temp.splice(2, toRemove);\n            decodedP.value = temp.join(\"\");\n          }\n        }\n\n        if (param.type === \"uint256\" || param.type === \"uint8\" || param.type === \"int\") {\n          // ensure to remove leading 0x for hex numbers\n          if (typeof decodedP.value === \"string\" && decodedP.value.startsWith(\"0x\")) {\n            decodedP.value = new BN(decodedP.value.slice(2), 16).toString(10);\n          } else {\n            decodedP.value = new BN(decodedP.value).toString(10);\n          }\n        }\n\n        decodedParams.push(decodedP);\n      });\n      return {\n        name: method.name,\n        events: decodedParams,\n        address: logItem.address\n      };\n    }\n  }).filter(decoded => state.keepNonDecodedLogs || decoded);\n}\n\nfunction _keepNonDecodedLogs() {\n  state.keepNonDecodedLogs = true;\n}\n\nfunction _discardNonDecodedLogs() {\n  state.keepNonDecodedLogs = false;\n}\n\nmodule.exports = {\n  getABIs: _getABIs,\n  addABI: _addABI,\n  getMethodIDs: _getMethodIDs,\n  decodeMethod: _decodeMethod,\n  decodeLogs: _decodeLogs,\n  removeABI: _removeABI,\n  keepNonDecodedLogs: _keepNonDecodedLogs,\n  discardNonDecodedLogs: _discardNonDecodedLogs\n};","map":{"version":3,"sources":["C:/Users/nomif/Desktop/Programming/Blockchain/ethereum-gasless-transactions/OpenGSN/node_modules/abi-decoder/index.js"],"names":["sha3","BN","require","abiCoder","state","savedABIs","methodIDs","keepNonDecodedLogs","_getABIs","_typeToString","input","type","components","map","join","_addABI","abiArray","Array","isArray","abi","name","signature","inputs","slice","concat","Error","_removeABI","_getMethodIDs","_decodeMethod","data","methodID","abiItem","decoded","decodeParameters","retData","params","i","__length__","param","parsedParam","isUint","indexOf","isInt","isAddress","val","toString","_","toLowerCase","push","value","_decodeLogs","logs","filter","log","topics","length","logItem","method","logData","decodedParams","dataIndex","topicsIndex","dataTypes","indexed","decodedData","decodedP","toRemove","temp","split","splice","startsWith","events","address","_keepNonDecodedLogs","_discardNonDecodedLogs","module","exports","getABIs","addABI","getMethodIDs","decodeMethod","decodeLogs","removeABI","discardNonDecodedLogs"],"mappings":"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","sourcesContent":["const { sha3, BN } = require(\"web3-utils\");\r\nconst abiCoder = require(\"web3-eth-abi\");\r\n\r\nconst state = {\r\n  savedABIs: [],\r\n  methodIDs: {},\r\n  keepNonDecodedLogs: false\r\n};\r\n\r\nfunction _getABIs() {\r\n  return state.savedABIs;\r\n}\r\n\r\nfunction _typeToString(input) {\r\n  if (input.type === \"tuple\") {\r\n    return \"(\" + input.components.map(_typeToString).join(\",\") + \")\";\r\n  }\r\n  return input.type;\r\n}\r\n\r\nfunction _addABI(abiArray) {\r\n\r\n  if (Array.isArray(abiArray)) {\r\n    // Iterate new abi to generate method id\"s\r\n    abiArray.map(function(abi) {\r\n      if (abi.name) {\r\n        const signature = sha3(\r\n          abi.name +\r\n            \"(\" +\r\n            abi.inputs\r\n              .map(_typeToString)\r\n              .join(\",\") +\r\n            \")\"\r\n        );\r\n        if (abi.type === \"event\") {\r\n          state.methodIDs[signature.slice(2)] = abi;\r\n        } else {\r\n          state.methodIDs[signature.slice(2, 10)] = abi;\r\n        }\r\n      }\r\n    });\r\n\r\n    state.savedABIs = state.savedABIs.concat(abiArray);\r\n  } else {\r\n    throw new Error(\"Expected ABI array, got \" + typeof abiArray);\r\n  }\r\n}\r\n\r\nfunction _removeABI(abiArray) {\r\n  if (Array.isArray(abiArray)) {\r\n    // Iterate new abi to generate method id\"s\r\n    abiArray.map(function(abi) {\r\n      if (abi.name) {\r\n        const signature = sha3(\r\n          abi.name +\r\n            \"(\" +\r\n            abi.inputs\r\n              .map(function(input) {\r\n                return input.type;\r\n              })\r\n              .join(\",\") +\r\n            \")\"\r\n        );\r\n        if (abi.type === \"event\") {\r\n          if (state.methodIDs[signature.slice(2)]) {\r\n            delete state.methodIDs[signature.slice(2)];\r\n          }\r\n        } else {\r\n          if (state.methodIDs[signature.slice(2, 10)]) {\r\n            delete state.methodIDs[signature.slice(2, 10)];\r\n          }\r\n        }\r\n      }\r\n    });\r\n  } else {\r\n    throw new Error(\"Expected ABI array, got \" + typeof abiArray);\r\n  }\r\n}\r\n\r\nfunction _getMethodIDs() {\r\n  return state.methodIDs;\r\n}\r\n\r\nfunction _decodeMethod(data) {\r\n  const methodID = data.slice(2, 10);\r\n  const abiItem = state.methodIDs[methodID];\r\n  if (abiItem) {\r\n    let decoded = abiCoder.decodeParameters(abiItem.inputs, data.slice(10));\r\n\r\n    let retData = {\r\n      name: abiItem.name,\r\n      params: [],\r\n    };\r\n\r\n    for (let i = 0; i < decoded.__length__; i++) {\r\n      let param = decoded[i];\r\n      let parsedParam = param;\r\n      const isUint = abiItem.inputs[i].type.indexOf(\"uint\") === 0;\r\n      const isInt = abiItem.inputs[i].type.indexOf(\"int\") === 0;\r\n      const isAddress = abiItem.inputs[i].type.indexOf(\"address\") === 0;\r\n\r\n      if (isUint || isInt) {\r\n        const isArray = Array.isArray(param);\r\n\r\n        if (isArray) {\r\n          parsedParam = param.map(val => new BN(val).toString());\r\n        } else {\r\n          parsedParam = new BN(param).toString();\r\n        }\r\n      }\r\n\r\n      // Addresses returned by web3 are randomly cased so we need to standardize and lowercase all\r\n      if (isAddress) {\r\n        const isArray = Array.isArray(param);\r\n\r\n        if (isArray) {\r\n          parsedParam = param.map(_ => _.toLowerCase());\r\n        } else {\r\n          parsedParam = param.toLowerCase();\r\n        }\r\n      }\r\n\r\n      retData.params.push({\r\n        name: abiItem.inputs[i].name,\r\n        value: parsedParam,\r\n        type: abiItem.inputs[i].type,\r\n      });\r\n    }\r\n\r\n    return retData;\r\n  }\r\n}\r\n\r\nfunction _decodeLogs(logs) {\r\n  return logs.filter(log => log.topics.length > 0).map((logItem) => {\r\n    const methodID = logItem.topics[0].slice(2);\r\n    const method = state.methodIDs[methodID];\r\n    if (method) {\r\n      const logData = logItem.data;\r\n      let decodedParams = [];\r\n      let dataIndex = 0;\r\n      let topicsIndex = 1;\r\n\r\n      let dataTypes = [];\r\n      method.inputs.map(function(input) {\r\n        if (!input.indexed) {\r\n          dataTypes.push(input.type);\r\n        }\r\n      });\r\n\r\n      const decodedData = abiCoder.decodeParameters(\r\n        dataTypes,\r\n        logData.slice(2)\r\n      );\r\n\r\n      // Loop topic and data to get the params\r\n      method.inputs.map(function(param) {\r\n        let decodedP = {\r\n          name: param.name,\r\n          type: param.type,\r\n        };\r\n\r\n        if (param.indexed) {\r\n          decodedP.value = logItem.topics[topicsIndex];\r\n          topicsIndex++;\r\n        } else {\r\n          decodedP.value = decodedData[dataIndex];\r\n          dataIndex++;\r\n        }\r\n\r\n        if (param.type === \"address\") {\r\n          decodedP.value = decodedP.value.toLowerCase();\r\n          // 42 because len(0x) + 40\r\n          if (decodedP.value.length > 42) {\r\n            let toRemove = decodedP.value.length - 42;\r\n            let temp = decodedP.value.split(\"\");\r\n            temp.splice(2, toRemove);\r\n            decodedP.value = temp.join(\"\");\r\n          }\r\n        }\r\n\r\n        if (\r\n          param.type === \"uint256\" ||\r\n          param.type === \"uint8\" ||\r\n          param.type === \"int\"\r\n        ) {\r\n          // ensure to remove leading 0x for hex numbers\r\n          if (typeof decodedP.value === \"string\" && decodedP.value.startsWith(\"0x\")) {\r\n            decodedP.value = new BN(decodedP.value.slice(2), 16).toString(10);\r\n          } else {\r\n            decodedP.value = new BN(decodedP.value).toString(10);\r\n          }\r\n\r\n        }\r\n\r\n        decodedParams.push(decodedP);\r\n      });\r\n\r\n      return {\r\n        name: method.name,\r\n        events: decodedParams,\r\n        address: logItem.address,\r\n      };\r\n    }\r\n  }).filter(decoded => state.keepNonDecodedLogs || decoded);\r\n}\r\n\r\nfunction _keepNonDecodedLogs(){\r\n  state.keepNonDecodedLogs = true\r\n}\r\n\r\nfunction _discardNonDecodedLogs(){\r\n  state.keepNonDecodedLogs = false\r\n}\r\n\r\nmodule.exports = {\r\n  getABIs: _getABIs,\r\n  addABI: _addABI,\r\n  getMethodIDs: _getMethodIDs,\r\n  decodeMethod: _decodeMethod,\r\n  decodeLogs: _decodeLogs,\r\n  removeABI: _removeABI,\r\n  keepNonDecodedLogs: _keepNonDecodedLogs,\r\n  discardNonDecodedLogs: _discardNonDecodedLogs\r\n};\r\n"]},"metadata":{},"sourceType":"script"}