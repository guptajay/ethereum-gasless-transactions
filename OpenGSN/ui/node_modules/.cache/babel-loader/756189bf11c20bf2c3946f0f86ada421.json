{"ast":null,"code":"'use strict';\n\nconst Buffer = require('safe-buffer').Buffer;\n\nconst Transform = require('stream').Transform;\n\nconst inherits = require('inherits');\n\nmodule.exports = function (KeccakState) {\n  function Shake(rate, capacity, delimitedSuffix, options) {\n    Transform.call(this, options);\n    this._rate = rate;\n    this._capacity = capacity;\n    this._delimitedSuffix = delimitedSuffix;\n    this._options = options;\n    this._state = new KeccakState();\n\n    this._state.initialize(rate, capacity);\n\n    this._finalized = false;\n  }\n\n  inherits(Shake, Transform);\n\n  Shake.prototype._transform = function (chunk, encoding, callback) {\n    let error = null;\n\n    try {\n      this.update(chunk, encoding);\n    } catch (err) {\n      error = err;\n    }\n\n    callback(error);\n  };\n\n  Shake.prototype._flush = function () {};\n\n  Shake.prototype._read = function (size) {\n    this.push(this.squeeze(size));\n  };\n\n  Shake.prototype.update = function (data, encoding) {\n    if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer');\n    if (this._finalized) throw new Error('Squeeze already called');\n    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding);\n\n    this._state.absorb(data);\n\n    return this;\n  };\n\n  Shake.prototype.squeeze = function (dataByteLength, encoding) {\n    if (!this._finalized) {\n      this._finalized = true;\n\n      this._state.absorbLastFewBits(this._delimitedSuffix);\n    }\n\n    let data = this._state.squeeze(dataByteLength);\n\n    if (encoding !== undefined) data = data.toString(encoding);\n    return data;\n  };\n\n  Shake.prototype._resetState = function () {\n    this._state.initialize(this._rate, this._capacity);\n\n    return this;\n  };\n\n  Shake.prototype._clone = function () {\n    const clone = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options);\n\n    this._state.copy(clone._state);\n\n    clone._finalized = this._finalized;\n    return clone;\n  };\n\n  return Shake;\n};","map":{"version":3,"sources":["C:/Users/nomif/Desktop/Programming/Blockchain/ethereum-gasless-transactions/OpenGSN/node_modules/@opengsn/common/node_modules/keccak/lib/api/shake.js"],"names":["Buffer","require","Transform","inherits","module","exports","KeccakState","Shake","rate","capacity","delimitedSuffix","options","call","_rate","_capacity","_delimitedSuffix","_options","_state","initialize","_finalized","prototype","_transform","chunk","encoding","callback","error","update","err","_flush","_read","size","push","squeeze","data","isBuffer","TypeError","Error","from","absorb","dataByteLength","absorbLastFewBits","undefined","toString","_resetState","_clone","clone","copy"],"mappings":"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","sourcesContent":["'use strict'\r\nconst Buffer = require('safe-buffer').Buffer\r\nconst Transform = require('stream').Transform\r\nconst inherits = require('inherits')\r\n\r\nmodule.exports = function (KeccakState) {\r\n  function Shake (rate, capacity, delimitedSuffix, options) {\r\n    Transform.call(this, options)\r\n\r\n    this._rate = rate\r\n    this._capacity = capacity\r\n    this._delimitedSuffix = delimitedSuffix\r\n    this._options = options\r\n\r\n    this._state = new KeccakState()\r\n    this._state.initialize(rate, capacity)\r\n    this._finalized = false\r\n  }\r\n\r\n  inherits(Shake, Transform)\r\n\r\n  Shake.prototype._transform = function (chunk, encoding, callback) {\r\n    let error = null\r\n    try {\r\n      this.update(chunk, encoding)\r\n    } catch (err) {\r\n      error = err\r\n    }\r\n\r\n    callback(error)\r\n  }\r\n\r\n  Shake.prototype._flush = function () {}\r\n\r\n  Shake.prototype._read = function (size) {\r\n    this.push(this.squeeze(size))\r\n  }\r\n\r\n  Shake.prototype.update = function (data, encoding) {\r\n    if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer')\r\n    if (this._finalized) throw new Error('Squeeze already called')\r\n    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)\r\n\r\n    this._state.absorb(data)\r\n\r\n    return this\r\n  }\r\n\r\n  Shake.prototype.squeeze = function (dataByteLength, encoding) {\r\n    if (!this._finalized) {\r\n      this._finalized = true\r\n      this._state.absorbLastFewBits(this._delimitedSuffix)\r\n    }\r\n\r\n    let data = this._state.squeeze(dataByteLength)\r\n    if (encoding !== undefined) data = data.toString(encoding)\r\n\r\n    return data\r\n  }\r\n\r\n  Shake.prototype._resetState = function () {\r\n    this._state.initialize(this._rate, this._capacity)\r\n    return this\r\n  }\r\n\r\n  Shake.prototype._clone = function () {\r\n    const clone = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options)\r\n    this._state.copy(clone._state)\r\n    clone._finalized = this._finalized\r\n\r\n    return clone\r\n  }\r\n\r\n  return Shake\r\n}\r\n"]},"metadata":{},"sourceType":"script"}