{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // @ts-ignore\n\nconst abi_decoder_1 = __importDefault(require(\"abi-decoder\"));\n\nconst IRelayHub_json_1 = __importDefault(require(\"@opengsn/common/dist/interfaces/IRelayHub.json\"));\n\nconst RelayClient_1 = require(\"./RelayClient\");\n\nabi_decoder_1.default.addABI(IRelayHub_json_1.default); // TODO: stop faking the HttpProvider implementation -  it won't work for any other 'origProvider' type\n\nclass RelayProvider {\n  constructor(relayClient) {\n    if (relayClient.send != null) {\n      throw new Error('Using new RelayProvider() constructor directly is deprecated.\\nPlease create provider using RelayProvider.newProvider({})');\n    }\n\n    this.relayClient = relayClient; // TODO: stop faking the HttpProvider implementation\n\n    this.origProvider = this.relayClient.getUnderlyingProvider();\n    this.host = this.origProvider.host;\n    this.connected = this.origProvider.connected;\n\n    if (typeof this.origProvider.sendAsync === 'function') {\n      this.origProviderSend = this.origProvider.sendAsync.bind(this.origProvider);\n    } else {\n      this.origProviderSend = this.origProvider.send.bind(this.origProvider);\n    }\n\n    this._delegateEventsApi();\n  }\n\n  static newProvider(input) {\n    return new RelayProvider(new RelayClient_1.RelayClient(input));\n  }\n\n  async init() {\n    await this.relayClient.init();\n    this.config = this.relayClient.config;\n    this.logger = this.relayClient.logger;\n    return this;\n  }\n\n  registerEventListener(handler) {\n    this.relayClient.registerEventListener(handler);\n  }\n\n  unregisterEventListener(handler) {\n    this.relayClient.unregisterEventListener(handler);\n  }\n\n  _delegateEventsApi() {\n    // If the subprovider is a ws or ipc provider, then register all its methods on this provider\n    // and delegate calls to the subprovider. This allows subscriptions to work.\n    ['on', 'removeListener', 'removeAllListeners', 'reset', 'disconnect', 'addDefaultEvents', 'once', 'reconnect'].forEach(func => {\n      // @ts-ignore\n      if (this.origProvider[func] !== undefined) {\n        // @ts-ignore\n        this[func] = this.origProvider[func].bind(this.origProvider);\n      }\n    });\n  }\n\n  send(payload, callback) {\n    if (this._useGSN(payload)) {\n      if (payload.method === 'eth_sendTransaction') {\n        if (payload.params[0].to === undefined) {\n          throw new Error('GSN cannot relay contract deployment transactions. Add {from: accountWithEther, useGSN: false}.');\n        }\n\n        this._ethSendTransaction(payload, callback);\n\n        return;\n      }\n\n      if (payload.method === 'eth_getTransactionReceipt') {\n        this._ethGetTransactionReceipt(payload, callback);\n\n        return;\n      }\n\n      if (payload.method === 'eth_accounts') {\n        this._getAccounts(payload, callback);\n      }\n    }\n\n    this.origProviderSend(payload, (error, result) => {\n      callback(error, result);\n    });\n  }\n\n  _ethGetTransactionReceipt(payload, callback) {\n    this.logger.info('calling sendAsync' + JSON.stringify(payload));\n    this.origProviderSend(payload, (error, rpcResponse) => {\n      // Sometimes, ganache seems to return 'false' for 'no error' (breaking TypeScript declarations)\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n      if (error) {\n        callback(error, rpcResponse);\n        return;\n      }\n\n      if (rpcResponse == null || rpcResponse.result == null) {\n        callback(error, rpcResponse);\n        return;\n      }\n\n      rpcResponse.result = this._getTranslatedGsnResponseResult(rpcResponse.result);\n      callback(error, rpcResponse);\n    });\n  }\n\n  _ethSendTransaction(payload, callback) {\n    this.logger.info('calling sendAsync' + JSON.stringify(payload));\n    const gsnTransactionDetails = payload.params[0];\n    this.relayClient.relayTransaction(gsnTransactionDetails).then(relayingResult => {\n      if (relayingResult.transaction != null) {\n        const jsonRpcSendResult = this._convertTransactionToRpcSendResponse(relayingResult.transaction, payload);\n\n        callback(null, jsonRpcSendResult);\n      } else {\n        const message = `Failed to relay call. Results:\\n${RelayClient_1._dumpRelayingResult(relayingResult)}`;\n        this.logger.error(message);\n        callback(new Error(message));\n      }\n    }, reason => {\n      const reasonStr = reason instanceof Error ? reason.message : JSON.stringify(reason);\n      const msg = `Rejected relayTransaction call with reason: ${reasonStr}`;\n      this.logger.info(msg);\n      callback(new Error(msg));\n    });\n  }\n\n  _convertTransactionToRpcSendResponse(transaction, request) {\n    var _a;\n\n    const txHash = transaction.hash(true).toString('hex');\n    const hash = `0x${txHash}`;\n    const id = (_a = typeof request.id === 'string' ? parseInt(request.id) : request.id) !== null && _a !== void 0 ? _a : -1;\n    return {\n      jsonrpc: '2.0',\n      id,\n      result: hash\n    };\n  }\n\n  _getTranslatedGsnResponseResult(respResult) {\n    const fixedTransactionReceipt = Object.assign({}, respResult);\n\n    if (respResult.logs.length === 0) {\n      return fixedTransactionReceipt;\n    }\n\n    const logs = abi_decoder_1.default.decodeLogs(respResult.logs);\n    const paymasterRejectedEvents = logs.find(e => e != null && e.name === 'TransactionRejectedByPaymaster');\n\n    if (paymasterRejectedEvents !== null && paymasterRejectedEvents !== undefined) {\n      const paymasterRejectionReason = paymasterRejectedEvents.events.find(e => e.name === 'reason');\n\n      if (paymasterRejectionReason !== undefined) {\n        this.logger.info(`Paymaster rejected on-chain: ${paymasterRejectionReason.value}. changing status to zero`);\n        fixedTransactionReceipt.status = '0';\n      }\n\n      return fixedTransactionReceipt;\n    }\n\n    const transactionRelayed = logs.find(e => e != null && e.name === 'TransactionRelayed');\n\n    if (transactionRelayed != null) {\n      const transactionRelayedStatus = transactionRelayed.events.find(e => e.name === 'status');\n\n      if (transactionRelayedStatus !== undefined) {\n        const status = transactionRelayedStatus.value.toString(); // 0 signifies success\n\n        if (status !== '0') {\n          this.logger.info(`reverted relayed transaction, status code ${status}. changing status to zero`);\n          fixedTransactionReceipt.status = '0';\n        }\n      }\n    }\n\n    return fixedTransactionReceipt;\n  }\n\n  _useGSN(payload) {\n    var _a;\n\n    if (payload.method === 'eth_accounts') {\n      return true;\n    }\n\n    if (payload.params[0] === undefined) {\n      return false;\n    }\n\n    const gsnTransactionDetails = payload.params[0];\n    return (_a = gsnTransactionDetails === null || gsnTransactionDetails === void 0 ? void 0 : gsnTransactionDetails.useGSN) !== null && _a !== void 0 ? _a : true;\n  }\n\n  supportsSubscriptions() {\n    return this.origProvider.supportsSubscriptions();\n  }\n\n  disconnect() {\n    return this.origProvider.disconnect();\n  }\n\n  newAccount() {\n    return this.relayClient.newAccount();\n  }\n\n  addAccount(privateKey) {\n    this.relayClient.addAccount(privateKey);\n  }\n\n  _getAccounts(payload, callback) {\n    this.origProviderSend(payload, (error, rpcResponse) => {\n      if (rpcResponse != null && Array.isArray(rpcResponse.result)) {\n        const ephemeralAccounts = this.relayClient.dependencies.accountManager.getAccounts();\n        rpcResponse.result = rpcResponse.result.concat(ephemeralAccounts);\n      }\n\n      callback(error, rpcResponse);\n    });\n  }\n\n}\n\nexports.RelayProvider = RelayProvider;","map":{"version":3,"sources":["../src/RelayProvider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// @ts-ignore\nconst abi_decoder_1 = __importDefault(require(\"abi-decoder\"));\nconst IRelayHub_json_1 = __importDefault(require(\"@opengsn/common/dist/interfaces/IRelayHub.json\"));\nconst RelayClient_1 = require(\"./RelayClient\");\nabi_decoder_1.default.addABI(IRelayHub_json_1.default);\n// TODO: stop faking the HttpProvider implementation -  it won't work for any other 'origProvider' type\nclass RelayProvider {\n    constructor(relayClient) {\n        if (relayClient.send != null) {\n            throw new Error('Using new RelayProvider() constructor directly is deprecated.\\nPlease create provider using RelayProvider.newProvider({})');\n        }\n        this.relayClient = relayClient;\n        // TODO: stop faking the HttpProvider implementation\n        this.origProvider = this.relayClient.getUnderlyingProvider();\n        this.host = this.origProvider.host;\n        this.connected = this.origProvider.connected;\n        if (typeof this.origProvider.sendAsync === 'function') {\n            this.origProviderSend = this.origProvider.sendAsync.bind(this.origProvider);\n        }\n        else {\n            this.origProviderSend = this.origProvider.send.bind(this.origProvider);\n        }\n        this._delegateEventsApi();\n    }\n    static newProvider(input) {\n        return new RelayProvider(new RelayClient_1.RelayClient(input));\n    }\n    async init() {\n        await this.relayClient.init();\n        this.config = this.relayClient.config;\n        this.logger = this.relayClient.logger;\n        return this;\n    }\n    registerEventListener(handler) {\n        this.relayClient.registerEventListener(handler);\n    }\n    unregisterEventListener(handler) {\n        this.relayClient.unregisterEventListener(handler);\n    }\n    _delegateEventsApi() {\n        // If the subprovider is a ws or ipc provider, then register all its methods on this provider\n        // and delegate calls to the subprovider. This allows subscriptions to work.\n        ['on', 'removeListener', 'removeAllListeners', 'reset', 'disconnect', 'addDefaultEvents', 'once', 'reconnect'].forEach(func => {\n            // @ts-ignore\n            if (this.origProvider[func] !== undefined) {\n                // @ts-ignore\n                this[func] = this.origProvider[func].bind(this.origProvider);\n            }\n        });\n    }\n    send(payload, callback) {\n        if (this._useGSN(payload)) {\n            if (payload.method === 'eth_sendTransaction') {\n                if (payload.params[0].to === undefined) {\n                    throw new Error('GSN cannot relay contract deployment transactions. Add {from: accountWithEther, useGSN: false}.');\n                }\n                this._ethSendTransaction(payload, callback);\n                return;\n            }\n            if (payload.method === 'eth_getTransactionReceipt') {\n                this._ethGetTransactionReceipt(payload, callback);\n                return;\n            }\n            if (payload.method === 'eth_accounts') {\n                this._getAccounts(payload, callback);\n            }\n        }\n        this.origProviderSend(payload, (error, result) => {\n            callback(error, result);\n        });\n    }\n    _ethGetTransactionReceipt(payload, callback) {\n        this.logger.info('calling sendAsync' + JSON.stringify(payload));\n        this.origProviderSend(payload, (error, rpcResponse) => {\n            // Sometimes, ganache seems to return 'false' for 'no error' (breaking TypeScript declarations)\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            if (error) {\n                callback(error, rpcResponse);\n                return;\n            }\n            if (rpcResponse == null || rpcResponse.result == null) {\n                callback(error, rpcResponse);\n                return;\n            }\n            rpcResponse.result = this._getTranslatedGsnResponseResult(rpcResponse.result);\n            callback(error, rpcResponse);\n        });\n    }\n    _ethSendTransaction(payload, callback) {\n        this.logger.info('calling sendAsync' + JSON.stringify(payload));\n        const gsnTransactionDetails = payload.params[0];\n        this.relayClient.relayTransaction(gsnTransactionDetails)\n            .then((relayingResult) => {\n            if (relayingResult.transaction != null) {\n                const jsonRpcSendResult = this._convertTransactionToRpcSendResponse(relayingResult.transaction, payload);\n                callback(null, jsonRpcSendResult);\n            }\n            else {\n                const message = `Failed to relay call. Results:\\n${RelayClient_1._dumpRelayingResult(relayingResult)}`;\n                this.logger.error(message);\n                callback(new Error(message));\n            }\n        }, (reason) => {\n            const reasonStr = reason instanceof Error ? reason.message : JSON.stringify(reason);\n            const msg = `Rejected relayTransaction call with reason: ${reasonStr}`;\n            this.logger.info(msg);\n            callback(new Error(msg));\n        });\n    }\n    _convertTransactionToRpcSendResponse(transaction, request) {\n        var _a;\n        const txHash = transaction.hash(true).toString('hex');\n        const hash = `0x${txHash}`;\n        const id = (_a = (typeof request.id === 'string' ? parseInt(request.id) : request.id)) !== null && _a !== void 0 ? _a : -1;\n        return {\n            jsonrpc: '2.0',\n            id,\n            result: hash\n        };\n    }\n    _getTranslatedGsnResponseResult(respResult) {\n        const fixedTransactionReceipt = Object.assign({}, respResult);\n        if (respResult.logs.length === 0) {\n            return fixedTransactionReceipt;\n        }\n        const logs = abi_decoder_1.default.decodeLogs(respResult.logs);\n        const paymasterRejectedEvents = logs.find((e) => e != null && e.name === 'TransactionRejectedByPaymaster');\n        if (paymasterRejectedEvents !== null && paymasterRejectedEvents !== undefined) {\n            const paymasterRejectionReason = paymasterRejectedEvents.events.find((e) => e.name === 'reason');\n            if (paymasterRejectionReason !== undefined) {\n                this.logger.info(`Paymaster rejected on-chain: ${paymasterRejectionReason.value}. changing status to zero`);\n                fixedTransactionReceipt.status = '0';\n            }\n            return fixedTransactionReceipt;\n        }\n        const transactionRelayed = logs.find((e) => e != null && e.name === 'TransactionRelayed');\n        if (transactionRelayed != null) {\n            const transactionRelayedStatus = transactionRelayed.events.find((e) => e.name === 'status');\n            if (transactionRelayedStatus !== undefined) {\n                const status = transactionRelayedStatus.value.toString();\n                // 0 signifies success\n                if (status !== '0') {\n                    this.logger.info(`reverted relayed transaction, status code ${status}. changing status to zero`);\n                    fixedTransactionReceipt.status = '0';\n                }\n            }\n        }\n        return fixedTransactionReceipt;\n    }\n    _useGSN(payload) {\n        var _a;\n        if (payload.method === 'eth_accounts') {\n            return true;\n        }\n        if (payload.params[0] === undefined) {\n            return false;\n        }\n        const gsnTransactionDetails = payload.params[0];\n        return (_a = gsnTransactionDetails === null || gsnTransactionDetails === void 0 ? void 0 : gsnTransactionDetails.useGSN) !== null && _a !== void 0 ? _a : true;\n    }\n    supportsSubscriptions() {\n        return this.origProvider.supportsSubscriptions();\n    }\n    disconnect() {\n        return this.origProvider.disconnect();\n    }\n    newAccount() {\n        return this.relayClient.newAccount();\n    }\n    addAccount(privateKey) {\n        this.relayClient.addAccount(privateKey);\n    }\n    _getAccounts(payload, callback) {\n        this.origProviderSend(payload, (error, rpcResponse) => {\n            if (rpcResponse != null && Array.isArray(rpcResponse.result)) {\n                const ephemeralAccounts = this.relayClient.dependencies.accountManager.getAccounts();\n                rpcResponse.result = rpcResponse.result.concat(ephemeralAccounts);\n            }\n            callback(error, rpcResponse);\n        });\n    }\n}\nexports.RelayProvider = RelayProvider;\n//# sourceMappingURL=RelayProvider.js.map"]},"metadata":{},"sourceType":"script"}