{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Address = void 0;\n\nconst assert_1 = __importDefault(require(\"assert\"));\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst bytes_1 = require(\"./bytes\");\n\nconst account_1 = require(\"./account\");\n\nclass Address {\n  constructor(buf) {\n    assert_1.default(buf.length === 20, 'Invalid address length');\n    this.buf = buf;\n  }\n  /**\r\n   * Returns the zero address.\r\n   */\n\n\n  static zero() {\n    return new Address(bytes_1.zeros(20));\n  }\n  /**\r\n   * Returns an Address object from a hex-encoded string.\r\n   * @param str - Hex-encoded address\r\n   */\n\n\n  static fromString(str) {\n    assert_1.default(account_1.isValidAddress(str), 'Invalid address');\n    return new Address(bytes_1.toBuffer(str));\n  }\n  /**\r\n   * Returns an address for a given public key.\r\n   * @param pubKey The two points of an uncompressed key\r\n   */\n\n\n  static fromPublicKey(pubKey) {\n    assert_1.default(Buffer.isBuffer(pubKey), 'Public key should be Buffer');\n    const buf = account_1.pubToAddress(pubKey);\n    return new Address(buf);\n  }\n  /**\r\n   * Returns an address for a given private key.\r\n   * @param privateKey A private key must be 256 bits wide\r\n   */\n\n\n  static fromPrivateKey(privateKey) {\n    assert_1.default(Buffer.isBuffer(privateKey), 'Private key should be Buffer');\n    const buf = account_1.privateToAddress(privateKey);\n    return new Address(buf);\n  }\n  /**\r\n   * Generates an address for a newly created contract.\r\n   * @param from The address which is creating this new address\r\n   * @param nonce The nonce of the from account\r\n   */\n\n\n  static generate(from, nonce) {\n    assert_1.default(bn_js_1.default.isBN(nonce));\n    return new Address(account_1.generateAddress(from.buf, nonce.toArrayLike(Buffer)));\n  }\n  /**\r\n   * Generates an address for a contract created using CREATE2.\r\n   * @param from The address which is creating this new address\r\n   * @param salt A salt\r\n   * @param initCode The init code of the contract being created\r\n   */\n\n\n  static generate2(from, salt, initCode) {\n    assert_1.default(Buffer.isBuffer(salt));\n    assert_1.default(Buffer.isBuffer(initCode));\n    return new Address(account_1.generateAddress2(from.buf, salt, initCode));\n  }\n  /**\r\n   * Is address equal to another.\r\n   */\n\n\n  equals(address) {\n    return this.buf.equals(address.buf);\n  }\n  /**\r\n   * Is address zero.\r\n   */\n\n\n  isZero() {\n    return this.equals(Address.zero());\n  }\n  /**\r\n   * True if address is in the address range defined\r\n   * by EIP-1352\r\n   */\n\n\n  isPrecompileOrSystemAddress() {\n    const addressBN = new bn_js_1.default(this.buf);\n    const rangeMin = new bn_js_1.default(0);\n    const rangeMax = new bn_js_1.default('ffff', 'hex');\n    return addressBN.gte(rangeMin) && addressBN.lte(rangeMax);\n  }\n  /**\r\n   * Returns hex encoding of address.\r\n   */\n\n\n  toString() {\n    return '0x' + this.buf.toString('hex');\n  }\n  /**\r\n   * Returns Buffer representation of address.\r\n   */\n\n\n  toBuffer() {\n    return Buffer.from(this.buf);\n  }\n\n}\n\nexports.Address = Address;","map":{"version":3,"sources":["../src/address.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Address = void 0;\r\nconst assert_1 = __importDefault(require(\"assert\"));\r\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\r\nconst bytes_1 = require(\"./bytes\");\r\nconst account_1 = require(\"./account\");\r\nclass Address {\r\n    constructor(buf) {\r\n        assert_1.default(buf.length === 20, 'Invalid address length');\r\n        this.buf = buf;\r\n    }\r\n    /**\r\n     * Returns the zero address.\r\n     */\r\n    static zero() {\r\n        return new Address(bytes_1.zeros(20));\r\n    }\r\n    /**\r\n     * Returns an Address object from a hex-encoded string.\r\n     * @param str - Hex-encoded address\r\n     */\r\n    static fromString(str) {\r\n        assert_1.default(account_1.isValidAddress(str), 'Invalid address');\r\n        return new Address(bytes_1.toBuffer(str));\r\n    }\r\n    /**\r\n     * Returns an address for a given public key.\r\n     * @param pubKey The two points of an uncompressed key\r\n     */\r\n    static fromPublicKey(pubKey) {\r\n        assert_1.default(Buffer.isBuffer(pubKey), 'Public key should be Buffer');\r\n        const buf = account_1.pubToAddress(pubKey);\r\n        return new Address(buf);\r\n    }\r\n    /**\r\n     * Returns an address for a given private key.\r\n     * @param privateKey A private key must be 256 bits wide\r\n     */\r\n    static fromPrivateKey(privateKey) {\r\n        assert_1.default(Buffer.isBuffer(privateKey), 'Private key should be Buffer');\r\n        const buf = account_1.privateToAddress(privateKey);\r\n        return new Address(buf);\r\n    }\r\n    /**\r\n     * Generates an address for a newly created contract.\r\n     * @param from The address which is creating this new address\r\n     * @param nonce The nonce of the from account\r\n     */\r\n    static generate(from, nonce) {\r\n        assert_1.default(bn_js_1.default.isBN(nonce));\r\n        return new Address(account_1.generateAddress(from.buf, nonce.toArrayLike(Buffer)));\r\n    }\r\n    /**\r\n     * Generates an address for a contract created using CREATE2.\r\n     * @param from The address which is creating this new address\r\n     * @param salt A salt\r\n     * @param initCode The init code of the contract being created\r\n     */\r\n    static generate2(from, salt, initCode) {\r\n        assert_1.default(Buffer.isBuffer(salt));\r\n        assert_1.default(Buffer.isBuffer(initCode));\r\n        return new Address(account_1.generateAddress2(from.buf, salt, initCode));\r\n    }\r\n    /**\r\n     * Is address equal to another.\r\n     */\r\n    equals(address) {\r\n        return this.buf.equals(address.buf);\r\n    }\r\n    /**\r\n     * Is address zero.\r\n     */\r\n    isZero() {\r\n        return this.equals(Address.zero());\r\n    }\r\n    /**\r\n     * True if address is in the address range defined\r\n     * by EIP-1352\r\n     */\r\n    isPrecompileOrSystemAddress() {\r\n        const addressBN = new bn_js_1.default(this.buf);\r\n        const rangeMin = new bn_js_1.default(0);\r\n        const rangeMax = new bn_js_1.default('ffff', 'hex');\r\n        return addressBN.gte(rangeMin) && addressBN.lte(rangeMax);\r\n    }\r\n    /**\r\n     * Returns hex encoding of address.\r\n     */\r\n    toString() {\r\n        return '0x' + this.buf.toString('hex');\r\n    }\r\n    /**\r\n     * Returns Buffer representation of address.\r\n     */\r\n    toBuffer() {\r\n        return Buffer.from(this.buf);\r\n    }\r\n}\r\nexports.Address = Address;\r\n//# sourceMappingURL=address.js.map"]},"metadata":{},"sourceType":"script"}