{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n\nconst ethUtil = require('ethereumjs-util');\n\nconst ethAbi = require('ethereumjs-abi');\n\nconst nacl = require('tweetnacl');\n\nnacl.util = require('tweetnacl-util');\nconst TYPED_MESSAGE_SCHEMA = {\n  type: 'object',\n  properties: {\n    types: {\n      type: 'object',\n      additionalProperties: {\n        type: 'array',\n        items: {\n          type: 'object',\n          properties: {\n            name: {\n              type: 'string'\n            },\n            type: {\n              type: 'string'\n            }\n          },\n          required: ['name', 'type']\n        }\n      }\n    },\n    primaryType: {\n      type: 'string'\n    },\n    domain: {\n      type: 'object'\n    },\n    message: {\n      type: 'object'\n    }\n  },\n  required: ['types', 'primaryType', 'domain', 'message']\n};\n/**\r\n * A collection of utility functions used for signing typed data\r\n */\n\nconst TypedDataUtils = {\n  /**\r\n   * Encodes an object by encoding and concatenating each of its members\r\n   *\r\n   * @param {string} primaryType - Root type\r\n   * @param {Object} data - Object to encode\r\n   * @param {Object} types - Type definitions\r\n   * @returns {string} - Encoded representation of an object\r\n   */\n  encodeData(primaryType, data, types) {\n    let useV4 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    const encodedTypes = ['bytes32'];\n    const encodedValues = [this.hashType(primaryType, types)];\n\n    if (useV4) {\n      const encodeField = (name, type, value) => {\n        if (types[type] !== undefined) {\n          return ['bytes32', value == null ? '0x0000000000000000000000000000000000000000000000000000000000000000' : ethUtil.sha3(this.encodeData(type, value, types, useV4))];\n        }\n\n        if (value === undefined) throw new Error(`missing value for field ${name} of type ${type}`);\n\n        if (type === 'bytes') {\n          return ['bytes32', ethUtil.sha3(value)];\n        }\n\n        if (type === 'string') {\n          // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n          if (typeof value === 'string') {\n            value = Buffer.from(value, 'utf8');\n          }\n\n          return ['bytes32', ethUtil.sha3(value)];\n        }\n\n        if (type.lastIndexOf(']') === type.length - 1) {\n          const parsedType = type.slice(0, type.lastIndexOf('['));\n          const typeValuePairs = value.map(item => encodeField(name, parsedType, item));\n          return ['bytes32', ethUtil.sha3(ethAbi.rawEncode(typeValuePairs.map(_ref => {\n            let [type] = _ref;\n            return type;\n          }), typeValuePairs.map(_ref2 => {\n            let [, value] = _ref2;\n            return value;\n          })))];\n        }\n\n        return [type, value];\n      };\n\n      for (const field of types[primaryType]) {\n        const [type, value] = encodeField(field.name, field.type, data[field.name]);\n        encodedTypes.push(type);\n        encodedValues.push(value);\n      }\n    } else {\n      for (const field of types[primaryType]) {\n        let value = data[field.name];\n\n        if (value !== undefined) {\n          if (field.type === 'bytes') {\n            encodedTypes.push('bytes32');\n            value = ethUtil.sha3(value);\n            encodedValues.push(value);\n          } else if (field.type === 'string') {\n            encodedTypes.push('bytes32'); // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n\n            if (typeof value === 'string') {\n              value = Buffer.from(value, 'utf8');\n            }\n\n            value = ethUtil.sha3(value);\n            encodedValues.push(value);\n          } else if (types[field.type] !== undefined) {\n            encodedTypes.push('bytes32');\n            value = ethUtil.sha3(this.encodeData(field.type, value, types, useV4));\n            encodedValues.push(value);\n          } else if (field.type.lastIndexOf(']') === field.type.length - 1) {\n            throw new Error('Arrays currently unimplemented in encodeData');\n          } else {\n            encodedTypes.push(field.type);\n            encodedValues.push(value);\n          }\n        }\n      }\n    }\n\n    return ethAbi.rawEncode(encodedTypes, encodedValues);\n  },\n\n  /**\r\n   * Encodes the type of an object by encoding a comma delimited list of its members\r\n   *\r\n   * @param {string} primaryType - Root type to encode\r\n   * @param {Object} types - Type definitions\r\n   * @returns {string} - Encoded representation of the type of an object\r\n   */\n  encodeType(primaryType, types) {\n    let result = '';\n    let deps = this.findTypeDependencies(primaryType, types).filter(dep => dep !== primaryType);\n    deps = [primaryType].concat(deps.sort());\n\n    for (const type of deps) {\n      const children = types[type];\n\n      if (!children) {\n        throw new Error('No type definition specified: ' + type);\n      }\n\n      result += type + '(' + types[type].map(_ref3 => {\n        let {\n          name,\n          type\n        } = _ref3;\n        return type + ' ' + name;\n      }).join(',') + ')';\n    }\n\n    return result;\n  },\n\n  /**\r\n   * Finds all types within a type defintion object\r\n   *\r\n   * @param {string} primaryType - Root type\r\n   * @param {Object} types - Type definitions\r\n   * @param {Array} results - current set of accumulated types\r\n   * @returns {Array} - Set of all types found in the type definition\r\n   */\n  findTypeDependencies(primaryType, types) {\n    let results = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    primaryType = primaryType.match(/^\\w*/)[0];\n\n    if (results.includes(primaryType) || types[primaryType] === undefined) {\n      return results;\n    }\n\n    results.push(primaryType);\n\n    for (const field of types[primaryType]) {\n      for (const dep of this.findTypeDependencies(field.type, types, results)) {\n        !results.includes(dep) && results.push(dep);\n      }\n    }\n\n    return results;\n  },\n\n  /**\r\n   * Hashes an object\r\n   *\r\n   * @param {string} primaryType - Root type\r\n   * @param {Object} data - Object to hash\r\n   * @param {Object} types - Type definitions\r\n   * @returns {string} - Hash of an object\r\n   */\n  hashStruct(primaryType, data, types) {\n    let useV4 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    return ethUtil.sha3(this.encodeData(primaryType, data, types, useV4));\n  },\n\n  /**\r\n   * Hashes the type of an object\r\n   *\r\n   * @param {string} primaryType - Root type to hash\r\n   * @param {Object} types - Type definitions\r\n   * @returns {string} - Hash of an object\r\n   */\n  hashType(primaryType, types) {\n    return ethUtil.sha3(this.encodeType(primaryType, types));\n  },\n\n  /**\r\n   * Removes properties from a message object that are not defined per EIP-712\r\n   *\r\n   * @param {Object} data - typed message object\r\n   * @returns {Object} - typed message object with only allowed fields\r\n   */\n  sanitizeData(data) {\n    const sanitizedData = {};\n\n    for (const key in TYPED_MESSAGE_SCHEMA.properties) {\n      data[key] && (sanitizedData[key] = data[key]);\n    }\n\n    if (sanitizedData.types) {\n      sanitizedData.types = Object.assign({\n        EIP712Domain: []\n      }, sanitizedData.types);\n    }\n\n    return sanitizedData;\n  },\n\n  /**\r\n   * Signs a typed message as per EIP-712 and returns its sha3 hash\r\n   *\r\n   * @param {Object} typedData - Types message data to sign\r\n   * @returns {string} - sha3 hash of the resulting signed message\r\n   */\n  sign(typedData) {\n    let useV4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const sanitizedData = this.sanitizeData(typedData);\n    const parts = [Buffer.from('1901', 'hex')];\n    parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4));\n\n    if (sanitizedData.primaryType !== 'EIP712Domain') {\n      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4));\n    }\n\n    return ethUtil.sha3(Buffer.concat(parts));\n  }\n\n};\nmodule.exports = {\n  TYPED_MESSAGE_SCHEMA,\n  TypedDataUtils,\n  concatSig: function (v, r, s) {\n    const rSig = ethUtil.fromSigned(r);\n    const sSig = ethUtil.fromSigned(s);\n    const vSig = ethUtil.bufferToInt(v);\n    const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString('hex'), 64);\n    const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString('hex'), 64);\n    const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig));\n    return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString('hex');\n  },\n  normalize: function (input) {\n    if (!input) return;\n\n    if (typeof input === 'number') {\n      const buffer = ethUtil.toBuffer(input);\n      input = ethUtil.bufferToHex(buffer);\n    }\n\n    if (typeof input !== 'string') {\n      var msg = 'eth-sig-util.normalize() requires hex string or integer input.';\n      msg += ' received ' + typeof input + ': ' + input;\n      throw new Error(msg);\n    }\n\n    return ethUtil.addHexPrefix(input.toLowerCase());\n  },\n  personalSign: function (privateKey, msgParams) {\n    var message = ethUtil.toBuffer(msgParams.data);\n    var msgHash = ethUtil.hashPersonalMessage(message);\n    var sig = ethUtil.ecsign(msgHash, privateKey);\n    var serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));\n    return serialized;\n  },\n  recoverPersonalSignature: function (msgParams) {\n    const publicKey = getPublicKeyFor(msgParams);\n    const sender = ethUtil.publicToAddress(publicKey);\n    const senderHex = ethUtil.bufferToHex(sender);\n    return senderHex;\n  },\n  extractPublicKey: function (msgParams) {\n    const publicKey = getPublicKeyFor(msgParams);\n    return '0x' + publicKey.toString('hex');\n  },\n  typedSignatureHash: function (typedData) {\n    const hashBuffer = typedSignatureHash(typedData);\n    return ethUtil.bufferToHex(hashBuffer);\n  },\n  signTypedDataLegacy: function (privateKey, msgParams) {\n    const msgHash = typedSignatureHash(msgParams.data);\n    const sig = ethUtil.ecsign(msgHash, privateKey);\n    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));\n  },\n  recoverTypedSignatureLegacy: function (msgParams) {\n    const msgHash = typedSignatureHash(msgParams.data);\n    const publicKey = recoverPublicKey(msgHash, msgParams.sig);\n    const sender = ethUtil.publicToAddress(publicKey);\n    return ethUtil.bufferToHex(sender);\n  },\n  encrypt: function (receiverPublicKey, msgParams, version) {\n    switch (version) {\n      case 'x25519-xsalsa20-poly1305':\n        if (typeof msgParams.data == 'undefined') {\n          throw new Error('Cannot detect secret message, message params should be of the form {data: \"secret message\"} ');\n        } //generate ephemeral keypair\n\n\n        var ephemeralKeyPair = nacl.box.keyPair(); // assemble encryption parameters - from string to UInt8\n\n        try {\n          var pubKeyUInt8Array = nacl.util.decodeBase64(receiverPublicKey);\n        } catch (err) {\n          throw new Error('Bad public key');\n        }\n\n        var msgParamsUInt8Array = nacl.util.decodeUTF8(msgParams.data);\n        var nonce = nacl.randomBytes(nacl.box.nonceLength); // encrypt\n\n        var encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey); // handle encrypted data\n\n        var output = {\n          version: 'x25519-xsalsa20-poly1305',\n          nonce: nacl.util.encodeBase64(nonce),\n          ephemPublicKey: nacl.util.encodeBase64(ephemeralKeyPair.publicKey),\n          ciphertext: nacl.util.encodeBase64(encryptedMessage)\n        }; // return encrypted msg data\n\n        return output;\n\n      default:\n        throw new Error('Encryption type/version not supported');\n    }\n  },\n  encryptSafely: function (receiverPublicKey, msgParams, version) {\n    const DEFAULT_PADDING_LENGTH = 2 ** 11;\n    const NACL_EXTRA_BYTES = 16;\n    let data = msgParams.data;\n\n    if (!data) {\n      throw new Error('Cannot encrypt empty msg.data');\n    }\n\n    if (typeof data === 'object' && data.toJSON) {\n      // remove toJSON attack vector\n      // TODO, check all possible children\n      throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property');\n    } // add padding\n\n\n    const dataWithPadding = {\n      data,\n      padding: ''\n    }; // calculate padding\n\n    const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8');\n    const modVal = dataLength % DEFAULT_PADDING_LENGTH;\n    let padLength = 0; // Only pad if necessary\n\n    if (modVal > 0) {\n      padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES; // nacl extra bytes\n    }\n\n    dataWithPadding.padding = '0'.repeat(padLength);\n    const paddedMsgParams = {\n      data: JSON.stringify(dataWithPadding)\n    };\n    return this.encrypt(receiverPublicKey, paddedMsgParams, version);\n  },\n  decrypt: function (encryptedData, receiverPrivateKey) {\n    switch (encryptedData.version) {\n      case 'x25519-xsalsa20-poly1305':\n        //string to buffer to UInt8Array\n        var recieverPrivateKeyUint8Array = nacl_decodeHex(receiverPrivateKey);\n        var recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey; // assemble decryption parameters\n\n        var nonce = nacl.util.decodeBase64(encryptedData.nonce);\n        var ciphertext = nacl.util.decodeBase64(encryptedData.ciphertext);\n        var ephemPublicKey = nacl.util.decodeBase64(encryptedData.ephemPublicKey); // decrypt\n\n        var decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey); // return decrypted msg data\n\n        try {\n          var output = nacl.util.encodeUTF8(decryptedMessage);\n        } catch (err) {\n          throw new Error('Decryption failed.');\n        }\n\n        if (output) {\n          return output;\n        } else {\n          throw new Error('Decryption failed.');\n        }\n\n      default:\n        throw new Error('Encryption type/version not supported.');\n    }\n  },\n  decryptSafely: function (encryptedData, receiverPrivateKey) {\n    const dataWithPadding = JSON.parse(this.decrypt(encryptedData, receiverPrivateKey));\n    return dataWithPadding.data;\n  },\n  getEncryptionPublicKey: function (privateKey) {\n    var privateKeyUint8Array = nacl_decodeHex(privateKey);\n    var encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;\n    return nacl.util.encodeBase64(encryptionPublicKey);\n  },\n\n  /**\r\n   * A generic entry point for all typed data methods to be passed, includes a version parameter.\r\n   */\n  signTypedMessage: function (privateKey, msgParams) {\n    let version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'V4';\n\n    switch (version) {\n      case 'V1':\n        return this.signTypedDataLegacy(privateKey, msgParams);\n\n      case 'V3':\n        return this.signTypedData(privateKey, msgParams);\n\n      case 'V4':\n      default:\n        return this.signTypedData_v4(privateKey, msgParams);\n    }\n  },\n  recoverTypedMessage: function (msgParams) {\n    let version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'V4';\n\n    switch (version) {\n      case 'V1':\n        return this.recoverTypedSignatureLegacy(msgParams);\n\n      case 'V3':\n        return this.recoverTypedSignature(msgParams);\n\n      case 'V4':\n      default:\n        return this.recoverTypedSignature_v4(msgParams);\n    }\n  },\n  signTypedData: function (privateKey, msgParams) {\n    const message = TypedDataUtils.sign(msgParams.data, false);\n    const sig = ethUtil.ecsign(message, privateKey);\n    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));\n  },\n  signTypedData_v4: function (privateKey, msgParams) {\n    const message = TypedDataUtils.sign(msgParams.data);\n    const sig = ethUtil.ecsign(message, privateKey);\n    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));\n  },\n  recoverTypedSignature: function (msgParams) {\n    const message = TypedDataUtils.sign(msgParams.data, false);\n    const publicKey = recoverPublicKey(message, msgParams.sig);\n    const sender = ethUtil.publicToAddress(publicKey);\n    return ethUtil.bufferToHex(sender);\n  },\n  recoverTypedSignature_v4: function (msgParams) {\n    const message = TypedDataUtils.sign(msgParams.data);\n    const publicKey = recoverPublicKey(message, msgParams.sig);\n    const sender = ethUtil.publicToAddress(publicKey);\n    return ethUtil.bufferToHex(sender);\n  }\n};\n/**\r\n * @param typedData - Array of data along with types, as per EIP712.\r\n * @returns Buffer\r\n */\n\nfunction typedSignatureHash(typedData) {\n  const error = new Error('Expect argument to be non-empty array');\n  if (typeof typedData !== 'object' || !typedData.length) throw error;\n  const data = typedData.map(function (e) {\n    return e.type === 'bytes' ? ethUtil.toBuffer(e.value) : e.value;\n  });\n  const types = typedData.map(function (e) {\n    return e.type;\n  });\n  const schema = typedData.map(function (e) {\n    if (!e.name) throw error;\n    return e.type + ' ' + e.name;\n  });\n  return ethAbi.soliditySHA3(['bytes32', 'bytes32'], [ethAbi.soliditySHA3(new Array(typedData.length).fill('string'), schema), ethAbi.soliditySHA3(types, data)]);\n}\n\nfunction recoverPublicKey(hash, sig) {\n  const signature = ethUtil.toBuffer(sig);\n  const sigParams = ethUtil.fromRpcSig(signature);\n  return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s);\n}\n\nfunction getPublicKeyFor(msgParams) {\n  const message = ethUtil.toBuffer(msgParams.data);\n  const msgHash = ethUtil.hashPersonalMessage(message);\n  return recoverPublicKey(msgHash, msgParams.sig);\n}\n\nfunction padWithZeroes(number, length) {\n  var myString = '' + number;\n\n  while (myString.length < length) {\n    myString = '0' + myString;\n  }\n\n  return myString;\n} //converts hex strings to the Uint8Array format used by nacl\n\n\nfunction nacl_decodeHex(msgHex) {\n  var msgBase64 = Buffer.from(msgHex, 'hex').toString('base64');\n  return nacl.util.decodeBase64(msgBase64);\n}","map":{"version":3,"sources":["C:/Users/nomif/Desktop/Programming/Blockchain/ethereum-gasless-transactions/OpenGSN/node_modules/@opengsn/common/node_modules/eth-sig-util/index.js"],"names":["Buffer","require","ethUtil","ethAbi","nacl","util","TYPED_MESSAGE_SCHEMA","type","properties","types","additionalProperties","items","name","required","primaryType","domain","message","TypedDataUtils","encodeData","data","useV4","encodedTypes","encodedValues","hashType","encodeField","value","undefined","sha3","Error","from","lastIndexOf","length","parsedType","slice","typeValuePairs","map","item","rawEncode","field","push","encodeType","result","deps","findTypeDependencies","filter","dep","concat","sort","children","join","results","match","includes","hashStruct","sanitizeData","sanitizedData","key","Object","assign","EIP712Domain","sign","typedData","parts","module","exports","concatSig","v","r","s","rSig","fromSigned","sSig","vSig","bufferToInt","rStr","padWithZeroes","toUnsigned","toString","sStr","vStr","stripHexPrefix","intToHex","addHexPrefix","normalize","input","buffer","toBuffer","bufferToHex","msg","toLowerCase","personalSign","privateKey","msgParams","msgHash","hashPersonalMessage","sig","ecsign","serialized","recoverPersonalSignature","publicKey","getPublicKeyFor","sender","publicToAddress","senderHex","extractPublicKey","typedSignatureHash","hashBuffer","signTypedDataLegacy","recoverTypedSignatureLegacy","recoverPublicKey","encrypt","receiverPublicKey","version","ephemeralKeyPair","box","keyPair","pubKeyUInt8Array","decodeBase64","err","msgParamsUInt8Array","decodeUTF8","nonce","randomBytes","nonceLength","encryptedMessage","secretKey","output","encodeBase64","ephemPublicKey","ciphertext","encryptSafely","DEFAULT_PADDING_LENGTH","NACL_EXTRA_BYTES","toJSON","dataWithPadding","padding","dataLength","byteLength","JSON","stringify","modVal","padLength","repeat","paddedMsgParams","decrypt","encryptedData","receiverPrivateKey","recieverPrivateKeyUint8Array","nacl_decodeHex","recieverEncryptionPrivateKey","fromSecretKey","decryptedMessage","open","encodeUTF8","decryptSafely","parse","getEncryptionPublicKey","privateKeyUint8Array","encryptionPublicKey","signTypedMessage","signTypedData","signTypedData_v4","recoverTypedMessage","recoverTypedSignature","recoverTypedSignature_v4","error","e","schema","soliditySHA3","Array","fill","hash","signature","sigParams","fromRpcSig","ecrecover","number","myString","msgHex","msgBase64"],"mappings":"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","sourcesContent":["const { Buffer } = require('buffer');\r\nconst ethUtil = require('ethereumjs-util');\r\nconst ethAbi = require('ethereumjs-abi');\r\nconst nacl = require('tweetnacl');\r\nnacl.util = require('tweetnacl-util');\r\n\r\nconst TYPED_MESSAGE_SCHEMA = {\r\n  type: 'object',\r\n  properties: {\r\n    types: {\r\n      type: 'object',\r\n      additionalProperties: {\r\n        type: 'array',\r\n        items: {\r\n          type: 'object',\r\n          properties: {\r\n            name: {type: 'string'},\r\n            type: {type: 'string'},\r\n          },\r\n          required: ['name', 'type'],\r\n        },\r\n      },\r\n    },\r\n    primaryType: {type: 'string'},\r\n    domain: {type: 'object'},\r\n    message: {type: 'object'},\r\n  },\r\n  required: ['types', 'primaryType', 'domain', 'message'],\r\n}\r\n\r\n/**\r\n * A collection of utility functions used for signing typed data\r\n */\r\nconst TypedDataUtils = {\r\n  /**\r\n   * Encodes an object by encoding and concatenating each of its members\r\n   *\r\n   * @param {string} primaryType - Root type\r\n   * @param {Object} data - Object to encode\r\n   * @param {Object} types - Type definitions\r\n   * @returns {string} - Encoded representation of an object\r\n   */\r\n  encodeData (primaryType, data, types, useV4 = true) {\r\n    const encodedTypes = ['bytes32']\r\n    const encodedValues = [this.hashType(primaryType, types)]\r\n\r\n    if(useV4) {\r\n      const encodeField = (name, type, value) => {\r\n        if (types[type] !== undefined) {\r\n          return ['bytes32', value == null ?\r\n            '0x0000000000000000000000000000000000000000000000000000000000000000' :\r\n            ethUtil.sha3(this.encodeData(type, value, types, useV4))]\r\n        }\r\n\r\n        if(value === undefined)\r\n          throw new Error(`missing value for field ${name} of type ${type}`)\r\n\r\n        if (type === 'bytes') {\r\n          return ['bytes32', ethUtil.sha3(value)]\r\n        }\r\n\r\n        if (type === 'string') {\r\n          // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\r\n          if (typeof value === 'string') {\r\n            value = Buffer.from(value, 'utf8')\r\n          }\r\n          return ['bytes32', ethUtil.sha3(value)]\r\n        }\r\n\r\n        if (type.lastIndexOf(']') === type.length - 1) {\r\n          const parsedType = type.slice(0, type.lastIndexOf('['))\r\n          const typeValuePairs = value.map(item =>\r\n            encodeField(name, parsedType, item))\r\n          return ['bytes32', ethUtil.sha3(ethAbi.rawEncode(\r\n            typeValuePairs.map(([type]) => type),\r\n            typeValuePairs.map(([, value]) => value),\r\n          ))]\r\n        }\r\n\r\n        return [type, value]\r\n      }\r\n\r\n      for (const field of types[primaryType]) {\r\n        const [type, value] = encodeField(field.name, field.type, data[field.name])\r\n        encodedTypes.push(type)\r\n        encodedValues.push(value)\r\n      }\r\n    } else {\r\n      for (const field of types[primaryType]) {\r\n        let value = data[field.name]\r\n        if (value !== undefined) {\r\n          if (field.type === 'bytes') {\r\n            encodedTypes.push('bytes32')\r\n            value = ethUtil.sha3(value)\r\n            encodedValues.push(value)\r\n          } else if (field.type === 'string') {\r\n            encodedTypes.push('bytes32')\r\n            // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\r\n            if (typeof value === 'string') {\r\n              value = Buffer.from(value, 'utf8')\r\n            }\r\n            value = ethUtil.sha3(value)\r\n            encodedValues.push(value)\r\n          } else if (types[field.type] !== undefined) {\r\n            encodedTypes.push('bytes32')\r\n            value = ethUtil.sha3(this.encodeData(field.type, value, types, useV4))\r\n            encodedValues.push(value)\r\n          } else if (field.type.lastIndexOf(']') === field.type.length - 1) {\r\n            throw new Error('Arrays currently unimplemented in encodeData')\r\n          } else {\r\n            encodedTypes.push(field.type)\r\n            encodedValues.push(value)\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return ethAbi.rawEncode(encodedTypes, encodedValues)\r\n  },\r\n\r\n  /**\r\n   * Encodes the type of an object by encoding a comma delimited list of its members\r\n   *\r\n   * @param {string} primaryType - Root type to encode\r\n   * @param {Object} types - Type definitions\r\n   * @returns {string} - Encoded representation of the type of an object\r\n   */\r\n  encodeType (primaryType, types) {\r\n    let result = ''\r\n    let deps = this.findTypeDependencies(primaryType, types).filter(dep => dep !== primaryType)\r\n    deps = [primaryType].concat(deps.sort())\r\n    for (const type of deps) {\r\n      const children = types[type]\r\n      if (!children) {\r\n        throw new Error('No type definition specified: ' + type)\r\n      }\r\n      result += type + '(' + types[type].map(({ name, type }) => type + ' ' + name).join(',') + ')'\r\n    }\r\n    return result\r\n  },\r\n\r\n  /**\r\n   * Finds all types within a type defintion object\r\n   *\r\n   * @param {string} primaryType - Root type\r\n   * @param {Object} types - Type definitions\r\n   * @param {Array} results - current set of accumulated types\r\n   * @returns {Array} - Set of all types found in the type definition\r\n   */\r\n  findTypeDependencies (primaryType, types, results = []) {\r\n    primaryType = primaryType.match(/^\\w*/)[0]\r\n    if (results.includes(primaryType) || types[primaryType] === undefined) { return results }\r\n    results.push(primaryType)\r\n    for (const field of types[primaryType]) {\r\n      for (const dep of this.findTypeDependencies(field.type, types, results)) {\r\n        !results.includes(dep) && results.push(dep)\r\n      }\r\n    }\r\n    return results\r\n  },\r\n\r\n  /**\r\n   * Hashes an object\r\n   *\r\n   * @param {string} primaryType - Root type\r\n   * @param {Object} data - Object to hash\r\n   * @param {Object} types - Type definitions\r\n   * @returns {string} - Hash of an object\r\n   */\r\n  hashStruct (primaryType, data, types, useV4 = true) {\r\n    return ethUtil.sha3(this.encodeData(primaryType, data, types, useV4))\r\n  },\r\n\r\n  /**\r\n   * Hashes the type of an object\r\n   *\r\n   * @param {string} primaryType - Root type to hash\r\n   * @param {Object} types - Type definitions\r\n   * @returns {string} - Hash of an object\r\n   */\r\n  hashType (primaryType, types) {\r\n    return ethUtil.sha3(this.encodeType(primaryType, types))\r\n  },\r\n\r\n  /**\r\n   * Removes properties from a message object that are not defined per EIP-712\r\n   *\r\n   * @param {Object} data - typed message object\r\n   * @returns {Object} - typed message object with only allowed fields\r\n   */\r\n  sanitizeData (data) {\r\n    const sanitizedData = {}\r\n    for (const key in TYPED_MESSAGE_SCHEMA.properties) {\r\n      data[key] && (sanitizedData[key] = data[key])\r\n    }\r\n    if (sanitizedData.types) {\r\n      sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types)\r\n    }\r\n    return sanitizedData\r\n  },\r\n\r\n  /**\r\n   * Signs a typed message as per EIP-712 and returns its sha3 hash\r\n   *\r\n   * @param {Object} typedData - Types message data to sign\r\n   * @returns {string} - sha3 hash of the resulting signed message\r\n   */\r\n  sign (typedData, useV4 = true) {\r\n    const sanitizedData = this.sanitizeData(typedData)\r\n    const parts = [Buffer.from('1901', 'hex')]\r\n    parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4))\r\n    if (sanitizedData.primaryType !== 'EIP712Domain') {\r\n      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4))\r\n    }\r\n    return ethUtil.sha3(Buffer.concat(parts))\r\n  },\r\n}\r\n\r\nmodule.exports = {\r\n  TYPED_MESSAGE_SCHEMA,\r\n  TypedDataUtils,\r\n\r\n  concatSig: function (v, r, s) {\r\n    const rSig = ethUtil.fromSigned(r)\r\n    const sSig = ethUtil.fromSigned(s)\r\n    const vSig = ethUtil.bufferToInt(v)\r\n    const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString('hex'), 64)\r\n    const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString('hex'), 64)\r\n    const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig))\r\n    return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString('hex')\r\n  },\r\n\r\n  normalize: function (input) {\r\n    if (!input) return\r\n\r\n    if (typeof input === 'number') {\r\n      const buffer = ethUtil.toBuffer(input)\r\n      input = ethUtil.bufferToHex(buffer)\r\n    }\r\n\r\n    if (typeof input !== 'string') {\r\n      var msg = 'eth-sig-util.normalize() requires hex string or integer input.'\r\n      msg += ' received ' + (typeof input) + ': ' + input\r\n      throw new Error(msg)\r\n    }\r\n\r\n    return ethUtil.addHexPrefix(input.toLowerCase())\r\n  },\r\n\r\n  personalSign: function (privateKey, msgParams) {\r\n    var message = ethUtil.toBuffer(msgParams.data)\r\n    var msgHash = ethUtil.hashPersonalMessage(message)\r\n    var sig = ethUtil.ecsign(msgHash, privateKey)\r\n    var serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))\r\n    return serialized\r\n  },\r\n\r\n  recoverPersonalSignature: function (msgParams) {\r\n    const publicKey = getPublicKeyFor(msgParams)\r\n    const sender = ethUtil.publicToAddress(publicKey)\r\n    const senderHex = ethUtil.bufferToHex(sender)\r\n    return senderHex\r\n  },\r\n\r\n  extractPublicKey: function (msgParams) {\r\n    const publicKey = getPublicKeyFor(msgParams)\r\n    return '0x' + publicKey.toString('hex')\r\n  },\r\n\r\n  typedSignatureHash: function (typedData) {\r\n    const hashBuffer = typedSignatureHash(typedData)\r\n    return ethUtil.bufferToHex(hashBuffer)\r\n  },\r\n\r\n  signTypedDataLegacy: function (privateKey, msgParams) {\r\n    const msgHash = typedSignatureHash(msgParams.data)\r\n    const sig = ethUtil.ecsign(msgHash, privateKey)\r\n    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))\r\n  },\r\n\r\n  recoverTypedSignatureLegacy: function (msgParams) {\r\n    const msgHash = typedSignatureHash(msgParams.data)\r\n    const publicKey = recoverPublicKey(msgHash, msgParams.sig)\r\n    const sender = ethUtil.publicToAddress(publicKey)\r\n    return ethUtil.bufferToHex(sender)\r\n  },\r\n\r\n  encrypt: function(receiverPublicKey, msgParams, version) {\r\n\r\n    switch(version) {\r\n      case 'x25519-xsalsa20-poly1305':\r\n        if( typeof msgParams.data == 'undefined'){\r\n          throw new Error('Cannot detect secret message, message params should be of the form {data: \"secret message\"} ')\r\n        }\r\n        //generate ephemeral keypair\r\n        var ephemeralKeyPair = nacl.box.keyPair()\r\n\r\n        // assemble encryption parameters - from string to UInt8\r\n        try {\r\n          var pubKeyUInt8Array = nacl.util.decodeBase64(receiverPublicKey);\r\n        } catch (err){\r\n          throw new Error('Bad public key')\r\n        }\r\n\r\n        var msgParamsUInt8Array = nacl.util.decodeUTF8(msgParams.data);\r\n        var nonce = nacl.randomBytes(nacl.box.nonceLength);\r\n\r\n        // encrypt\r\n        var encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey);\r\n\r\n        // handle encrypted data\r\n        var output = {\r\n          version: 'x25519-xsalsa20-poly1305',\r\n          nonce: nacl.util.encodeBase64(nonce),\r\n          ephemPublicKey: nacl.util.encodeBase64(ephemeralKeyPair.publicKey),\r\n          ciphertext: nacl.util.encodeBase64(encryptedMessage)\r\n        };\r\n        // return encrypted msg data\r\n        return output;\r\n\r\n      default:\r\n        throw new Error('Encryption type/version not supported')\r\n\r\n    }\r\n  },\r\n\r\n  encryptSafely: function(receiverPublicKey, msgParams, version) {\r\n\r\n    const DEFAULT_PADDING_LENGTH = (2 ** 11);\r\n    const NACL_EXTRA_BYTES = 16;\r\n\r\n    let data = msgParams.data;\r\n    if (!data) {\r\n      throw new Error('Cannot encrypt empty msg.data');\r\n    }\r\n\r\n    if (typeof data === 'object' && data.toJSON) {\r\n      // remove toJSON attack vector\r\n      // TODO, check all possible children\r\n      throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property');\r\n    }\r\n\r\n    // add padding\r\n    const dataWithPadding = {\r\n      data,\r\n      padding: '',\r\n    };\r\n\r\n    // calculate padding\r\n    const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8');\r\n    const modVal = (dataLength % DEFAULT_PADDING_LENGTH);\r\n    let padLength = 0;\r\n    // Only pad if necessary\r\n    if (modVal > 0) {\r\n      padLength = (DEFAULT_PADDING_LENGTH - modVal) - NACL_EXTRA_BYTES; // nacl extra bytes\r\n    }\r\n    dataWithPadding.padding = '0'.repeat(padLength);\r\n\r\n    const paddedMsgParams = {data:JSON.stringify(dataWithPadding)};\r\n    return this.encrypt(receiverPublicKey, paddedMsgParams, version);\r\n  },\r\n\r\n  decrypt: function(encryptedData, receiverPrivateKey) {\r\n\r\n    switch(encryptedData.version) {\r\n      case 'x25519-xsalsa20-poly1305':\r\n        //string to buffer to UInt8Array\r\n        var recieverPrivateKeyUint8Array = nacl_decodeHex(receiverPrivateKey)\r\n        var recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey\r\n\r\n        // assemble decryption parameters\r\n        var nonce = nacl.util.decodeBase64(encryptedData.nonce);\r\n        var ciphertext = nacl.util.decodeBase64(encryptedData.ciphertext);\r\n        var ephemPublicKey = nacl.util.decodeBase64(encryptedData.ephemPublicKey);\r\n\r\n        // decrypt\r\n        var decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey);\r\n\r\n        // return decrypted msg data\r\n        try {\r\n          var output = nacl.util.encodeUTF8(decryptedMessage);\r\n        }catch(err) {\r\n          throw new Error('Decryption failed.')\r\n        }\r\n\r\n        if (output){\r\n          return output;\r\n        }else{\r\n          throw new Error('Decryption failed.')\r\n        }\r\n\r\n\r\n      default:\r\n        throw new Error('Encryption type/version not supported.')\r\n    }\r\n  },\r\n\r\n  decryptSafely: function(encryptedData, receiverPrivateKey) {\r\n    const dataWithPadding = JSON.parse(this.decrypt(encryptedData, receiverPrivateKey));\r\n    return dataWithPadding.data;\r\n  },\r\n\r\n\r\n  getEncryptionPublicKey: function(privateKey){\r\n    var privateKeyUint8Array = nacl_decodeHex(privateKey)\r\n    var encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey\r\n    return nacl.util.encodeBase64(encryptionPublicKey)\r\n  },\r\n\r\n\r\n  /**\r\n   * A generic entry point for all typed data methods to be passed, includes a version parameter.\r\n   */\r\n  signTypedMessage: function (privateKey, msgParams, version = 'V4') {\r\n    switch (version) {\r\n      case 'V1':\r\n        return this.signTypedDataLegacy(privateKey, msgParams)\r\n      case 'V3':\r\n        return this.signTypedData(privateKey, msgParams)\r\n      case 'V4':\r\n      default:\r\n        return this.signTypedData_v4(privateKey, msgParams)\r\n    }\r\n  },\r\n\r\n  recoverTypedMessage: function (msgParams, version = 'V4') {\r\n    switch (version) {\r\n      case 'V1':\r\n        return this.recoverTypedSignatureLegacy(msgParams)\r\n      case 'V3':\r\n        return this.recoverTypedSignature(msgParams)\r\n      case 'V4':\r\n      default:\r\n        return this.recoverTypedSignature_v4(msgParams)\r\n    }\r\n  },\r\n\r\n  signTypedData: function (privateKey, msgParams) {\r\n    const message = TypedDataUtils.sign(msgParams.data, false)\r\n    const sig = ethUtil.ecsign(message, privateKey)\r\n    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))\r\n  },\r\n\r\n  signTypedData_v4: function (privateKey, msgParams) {\r\n    const message = TypedDataUtils.sign(msgParams.data)\r\n    const sig = ethUtil.ecsign(message, privateKey)\r\n    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))\r\n  },\r\n\r\n  recoverTypedSignature: function (msgParams) {\r\n    const message = TypedDataUtils.sign(msgParams.data, false)\r\n    const publicKey = recoverPublicKey(message, msgParams.sig)\r\n    const sender = ethUtil.publicToAddress(publicKey)\r\n    return ethUtil.bufferToHex(sender)\r\n  },\r\n\r\n  recoverTypedSignature_v4: function (msgParams) {\r\n    const message = TypedDataUtils.sign(msgParams.data)\r\n    const publicKey = recoverPublicKey(message, msgParams.sig)\r\n    const sender = ethUtil.publicToAddress(publicKey)\r\n    return ethUtil.bufferToHex(sender)\r\n  },\r\n\r\n}\r\n\r\n/**\r\n * @param typedData - Array of data along with types, as per EIP712.\r\n * @returns Buffer\r\n */\r\nfunction typedSignatureHash(typedData) {\r\n  const error = new Error('Expect argument to be non-empty array')\r\n  if (typeof typedData !== 'object' || !typedData.length) throw error\r\n\r\n  const data = typedData.map(function (e) {\r\n    return e.type === 'bytes' ? ethUtil.toBuffer(e.value) : e.value\r\n  })\r\n  const types = typedData.map(function (e) { return e.type })\r\n  const schema = typedData.map(function (e) {\r\n    if (!e.name) throw error\r\n    return e.type + ' ' + e.name\r\n  })\r\n\r\n  return ethAbi.soliditySHA3(\r\n    ['bytes32', 'bytes32'],\r\n    [\r\n      ethAbi.soliditySHA3(new Array(typedData.length).fill('string'), schema),\r\n      ethAbi.soliditySHA3(types, data)\r\n    ]\r\n  )\r\n}\r\n\r\nfunction recoverPublicKey(hash, sig) {\r\n  const signature = ethUtil.toBuffer(sig)\r\n  const sigParams = ethUtil.fromRpcSig(signature)\r\n  return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s)\r\n}\r\n\r\nfunction getPublicKeyFor (msgParams) {\r\n  const message = ethUtil.toBuffer(msgParams.data)\r\n  const msgHash = ethUtil.hashPersonalMessage(message)\r\n  return recoverPublicKey(msgHash, msgParams.sig)\r\n}\r\n\r\n\r\nfunction padWithZeroes (number, length) {\r\n  var myString = '' + number\r\n  while (myString.length < length) {\r\n    myString = '0' + myString\r\n  }\r\n  return myString\r\n}\r\n\r\n//converts hex strings to the Uint8Array format used by nacl\r\nfunction nacl_decodeHex(msgHex) {\r\n  var msgBase64 = (Buffer.from(msgHex, 'hex')).toString('base64');\r\n  return nacl.util.decodeBase64(msgBase64);\r\n}\r\n\r\n\r\n\r\n"]},"metadata":{},"sourceType":"script"}