{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst web3_1 = __importDefault(require(\"web3\"));\n\nconst web3_utils_1 = require(\"web3-utils\");\n\nfunction getComponent(key, components) {\n  // @ts-ignore\n  const component = components[key];\n\n  if (component != null) {\n    return component;\n  }\n\n  return components.find(it => it.name === key);\n}\n\nfunction retypeItem(abiOutput, ret) {\n  if (abiOutput.type.includes('int')) {\n    return web3_utils_1.toBN(ret);\n  } else if (abiOutput.type.includes('tuple') && abiOutput.components != null) {\n    const keys = Object.keys(ret);\n    const newRet = {};\n\n    for (let i = 0; i < keys.length; i++) {\n      const component = getComponent(keys[i], abiOutput.components);\n\n      if (component == null) {\n        continue;\n      }\n\n      newRet[keys[i]] = retypeItem(component, ret[keys[i]]);\n    }\n\n    return newRet;\n  } else {\n    return ret;\n  }\n} // restore TF type: uint are returned as string in web3, and as BN in TF.\n\n\nfunction retype(outputs, ret) {\n  if ((outputs === null || outputs === void 0 ? void 0 : outputs.length) === 1) {\n    return retypeItem(outputs[0], ret);\n  } else {\n    return ret;\n  }\n}\n\nclass Contract {\n  constructor(contractName, abi) {\n    this.contractName = contractName;\n    this.abi = abi;\n  }\n\n  createContract(address) {\n    return new this.web3.eth.Contract(this.abi, address);\n  } // return a contract instance at the given address.\n  // UNLIKE TF, we don't do any on-chain check if the contract exist.\n  // the application is assumed to call some view function (e.g. version) that implicitly verifies a contract\n  // is deployed at that address (and has that view function)\n\n\n  async at(address) {\n    const contract = this.createContract(address);\n    const obj = {\n      address,\n      contract,\n\n      async getPastEvents(name, options) {\n        // @ts-ignore\n        return contract.getPastEvents(name, options).map(e => Object.assign(Object.assign({}, e), {\n          args: e.returnValues // TODO: web3 uses strings, Truffle uses BN for numbers\n\n        }));\n      }\n\n    };\n    this.abi.forEach(m => {\n      var _a, _b, _c;\n\n      const methodName = (_a = m.name) !== null && _a !== void 0 ? _a : '';\n      const nArgs = (_c = (_b = m.inputs) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;\n      const isViewFunction = m.stateMutability === 'view' || m.stateMutability === 'pure';\n\n      obj[methodName] = async function () {\n        let args = Array.from(arguments);\n        let options;\n\n        if (args.length === nArgs + 1 && typeof args[args.length - 1] === 'object') {\n          options = args[args.length - 1];\n          args = args.slice(0, args.length - 1);\n        }\n\n        const methodCall = contract.methods[methodName].apply(contract.methods, args);\n\n        if (!isViewFunction) {\n          return methodCall.send(options);\n        } else {\n          return methodCall.call(options).then(res => {\n            return retype(m.outputs, res);\n          });\n        } // console.log('===calling', methodName, args)\n        // return await methodCall.call(options)\n        //   .catch((e: Error) => {\n        //     console.log('===ex1', e)\n        //     throw e\n        //   })\n\n      };\n    });\n    return obj;\n  }\n\n  setProvider(provider, _) {\n    this.web3 = new web3_1.default(provider);\n  }\n\n}\n\nexports.Contract = Contract;\n\nfunction TruffleContract(_ref) {\n  let {\n    contractName,\n    abi\n  } = _ref;\n  return new Contract(contractName, abi);\n}\n\nexports.TruffleContract = TruffleContract;","map":{"version":3,"sources":["../src/LightTruffleContract.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst web3_1 = __importDefault(require(\"web3\"));\nconst web3_utils_1 = require(\"web3-utils\");\nfunction getComponent(key, components) {\n    // @ts-ignore\n    const component = components[key];\n    if (component != null) {\n        return component;\n    }\n    return components.find(it => it.name === key);\n}\nfunction retypeItem(abiOutput, ret) {\n    if (abiOutput.type.includes('int')) {\n        return web3_utils_1.toBN(ret);\n    }\n    else if (abiOutput.type.includes('tuple') && abiOutput.components != null) {\n        const keys = Object.keys(ret);\n        const newRet = {};\n        for (let i = 0; i < keys.length; i++) {\n            const component = getComponent(keys[i], abiOutput.components);\n            if (component == null) {\n                continue;\n            }\n            newRet[keys[i]] = retypeItem(component, ret[keys[i]]);\n        }\n        return newRet;\n    }\n    else {\n        return ret;\n    }\n}\n// restore TF type: uint are returned as string in web3, and as BN in TF.\nfunction retype(outputs, ret) {\n    if ((outputs === null || outputs === void 0 ? void 0 : outputs.length) === 1) {\n        return retypeItem(outputs[0], ret);\n    }\n    else {\n        return ret;\n    }\n}\nclass Contract {\n    constructor(contractName, abi) {\n        this.contractName = contractName;\n        this.abi = abi;\n    }\n    createContract(address) {\n        return new this.web3.eth.Contract(this.abi, address);\n    }\n    // return a contract instance at the given address.\n    // UNLIKE TF, we don't do any on-chain check if the contract exist.\n    // the application is assumed to call some view function (e.g. version) that implicitly verifies a contract\n    // is deployed at that address (and has that view function)\n    async at(address) {\n        const contract = this.createContract(address);\n        const obj = {\n            address,\n            contract,\n            async getPastEvents(name, options) {\n                // @ts-ignore\n                return contract.getPastEvents(name, options).map(e => (Object.assign(Object.assign({}, e), { args: e.returnValues // TODO: web3 uses strings, Truffle uses BN for numbers\n                 })));\n            }\n        };\n        this.abi.forEach(m => {\n            var _a, _b, _c;\n            const methodName = (_a = m.name) !== null && _a !== void 0 ? _a : '';\n            const nArgs = (_c = (_b = m.inputs) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;\n            const isViewFunction = m.stateMutability === 'view' || m.stateMutability === 'pure';\n            obj[methodName] = async function () {\n                let args = Array.from(arguments);\n                let options;\n                if (args.length === nArgs + 1 && typeof args[args.length - 1] === 'object') {\n                    options = args[args.length - 1];\n                    args = args.slice(0, args.length - 1);\n                }\n                const methodCall = contract.methods[methodName].apply(contract.methods, args);\n                if (!isViewFunction) {\n                    return methodCall.send(options);\n                }\n                else {\n                    return methodCall.call(options)\n                        .then((res) => {\n                        return retype(m.outputs, res);\n                    });\n                }\n                // console.log('===calling', methodName, args)\n                // return await methodCall.call(options)\n                //   .catch((e: Error) => {\n                //     console.log('===ex1', e)\n                //     throw e\n                //   })\n            };\n        });\n        return obj;\n    }\n    setProvider(provider, _) {\n        this.web3 = new web3_1.default(provider);\n    }\n}\nexports.Contract = Contract;\nfunction TruffleContract({ contractName, abi }) {\n    return new Contract(contractName, abi);\n}\nexports.TruffleContract = TruffleContract;\n//# sourceMappingURL=LightTruffleContract.js.map"]},"metadata":{},"sourceType":"script"}