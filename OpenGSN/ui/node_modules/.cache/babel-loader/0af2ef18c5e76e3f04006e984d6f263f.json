{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ErrorReplacerJSON_1 = require(\"@opengsn/common/dist/ErrorReplacerJSON\");\n\nconst GSNContractsDataTypes_1 = require(\"@opengsn/common/dist/types/GSNContractsDataTypes\");\n\nclass RelaySelectionManager {\n  constructor(gsnTransactionDetails, knownRelaysManager, httpClient, pingFilter, logger, config) {\n    this.remainingRelays = [];\n    this.isInitialized = false;\n    this.errors = new Map();\n    this.gsnTransactionDetails = gsnTransactionDetails;\n    this.knownRelaysManager = knownRelaysManager;\n    this.httpClient = httpClient;\n    this.pingFilter = pingFilter;\n    this.config = config;\n    this.logger = logger;\n  }\n  /**\n   * Ping those relays that were not pinged yet, and remove both the returned relay or relays re from {@link remainingRelays}\n   * @returns the first relay to respond to a ping message. Note: will never return the same relay twice.\n   */\n\n\n  async selectNextRelay() {\n    while (true) {\n      const slice = this._getNextSlice();\n\n      let relayInfo;\n\n      if (slice.length > 0) {\n        relayInfo = await this._nextRelayInternal(slice);\n\n        if (relayInfo == null) {\n          continue;\n        }\n      }\n\n      return relayInfo;\n    }\n  }\n\n  async _nextRelayInternal(relays) {\n    this.logger.info('nextRelay: find fastest relay from: ' + JSON.stringify(relays));\n    const raceResult = await this._raceToSuccess(relays);\n    this.logger.info(`race finished with a result: ${JSON.stringify(raceResult, ErrorReplacerJSON_1.replaceErrors)}`);\n\n    this._handleRaceResults(raceResult);\n\n    if (raceResult.winner != null) {\n      if (GSNContractsDataTypes_1.isInfoFromEvent(raceResult.winner.relayInfo)) {\n        return raceResult.winner;\n      } else {\n        const managerAddress = raceResult.winner.pingResponse.relayManagerAddress;\n        this.logger.info(`finding relay register info for manager address: ${managerAddress}; known info: ${JSON.stringify(raceResult.winner.relayInfo)}`);\n        const events = await this.knownRelaysManager.getRelayInfoForManagers(new Set([managerAddress]));\n\n        if (events.length === 1) {\n          // as preferred relay URL is not guaranteed to match the advertised one for the same manager, preserve URL\n          const relayInfo = events[0];\n          relayInfo.relayUrl = raceResult.winner.relayInfo.relayUrl;\n          return {\n            pingResponse: raceResult.winner.pingResponse,\n            relayInfo\n          };\n        } else {\n          // TODO: do not throw! The preferred relay may be removed since.\n          throw new Error('Could not find register event for the winning preferred relay');\n        }\n      }\n    }\n  }\n\n  async init() {\n    this.remainingRelays = await this.knownRelaysManager.getRelaysSortedForTransaction(this.gsnTransactionDetails);\n    this.isInitialized = true;\n    return this;\n  } // relays left to try\n  // (note that some edge-cases (like duplicate urls) are not filtered out)\n\n\n  relaysLeft() {\n    return this.remainingRelays.flatMap(list => list);\n  }\n\n  _getNextSlice() {\n    if (!this.isInitialized) {\n      throw new Error('init() not called');\n    }\n\n    for (const relays of this.remainingRelays) {\n      const bulkSize = Math.min(this.config.sliceSize, relays.length);\n      const slice = relays.slice(0, bulkSize);\n\n      if (slice.length === 0) {\n        continue;\n      }\n\n      return slice;\n    }\n\n    return [];\n  }\n  /**\n   * @returns JSON response from the relay server, but adds the requested URL to it :'-(\n   */\n\n\n  async _getRelayAddressPing(relayInfo) {\n    this.logger.info(`getRelayAddressPing URL: ${relayInfo.relayUrl}`);\n    const pingResponse = await this.httpClient.getPingResponse(relayInfo.relayUrl, this.gsnTransactionDetails.paymaster);\n\n    if (!pingResponse.ready) {\n      throw new Error(`Relay not ready ${JSON.stringify(pingResponse)}`);\n    }\n\n    this.pingFilter(pingResponse, this.gsnTransactionDetails);\n    return {\n      pingResponse,\n      relayInfo\n    };\n  }\n  /**\n   * From https://stackoverflow.com/a/37235207 (added types, modified to catch exceptions)\n   * Accepts an array of promises.\n   * Resolves once any promise resolves, ignores the rest. Exceptions returned separately.\n   */\n\n\n  async _raceToSuccess(relays) {\n    const errors = new Map();\n    return await new Promise(resolve => {\n      relays.forEach(relay => {\n        this._getRelayAddressPing(relay).then(winner => {\n          resolve({\n            winner,\n            errors\n          });\n        }).catch(err => {\n          errors.set(relay.relayUrl, err);\n\n          if (errors.size === relays.length) {\n            resolve({\n              errors\n            });\n          }\n        });\n      });\n    });\n  }\n\n  _handleRaceResults(raceResult) {\n    if (!this.isInitialized) {\n      throw new Error('init() not called');\n    }\n\n    this.errors = new Map([...this.errors, ...raceResult.errors]);\n    this.remainingRelays = this.remainingRelays.map(relays => relays.filter(eventInfo => {\n      var _a;\n\n      return eventInfo.relayUrl !== ((_a = raceResult.winner) === null || _a === void 0 ? void 0 : _a.relayInfo.relayUrl);\n    }).filter(eventInfo => !Array.from(raceResult.errors.keys()).includes(eventInfo.relayUrl)));\n  }\n\n}\n\nexports.RelaySelectionManager = RelaySelectionManager;","map":{"version":3,"sources":["../src/RelaySelectionManager.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ErrorReplacerJSON_1 = require(\"@opengsn/common/dist/ErrorReplacerJSON\");\nconst GSNContractsDataTypes_1 = require(\"@opengsn/common/dist/types/GSNContractsDataTypes\");\nclass RelaySelectionManager {\n    constructor(gsnTransactionDetails, knownRelaysManager, httpClient, pingFilter, logger, config) {\n        this.remainingRelays = [];\n        this.isInitialized = false;\n        this.errors = new Map();\n        this.gsnTransactionDetails = gsnTransactionDetails;\n        this.knownRelaysManager = knownRelaysManager;\n        this.httpClient = httpClient;\n        this.pingFilter = pingFilter;\n        this.config = config;\n        this.logger = logger;\n    }\n    /**\n     * Ping those relays that were not pinged yet, and remove both the returned relay or relays re from {@link remainingRelays}\n     * @returns the first relay to respond to a ping message. Note: will never return the same relay twice.\n     */\n    async selectNextRelay() {\n        while (true) {\n            const slice = this._getNextSlice();\n            let relayInfo;\n            if (slice.length > 0) {\n                relayInfo = await this._nextRelayInternal(slice);\n                if (relayInfo == null) {\n                    continue;\n                }\n            }\n            return relayInfo;\n        }\n    }\n    async _nextRelayInternal(relays) {\n        this.logger.info('nextRelay: find fastest relay from: ' + JSON.stringify(relays));\n        const raceResult = await this._raceToSuccess(relays);\n        this.logger.info(`race finished with a result: ${JSON.stringify(raceResult, ErrorReplacerJSON_1.replaceErrors)}`);\n        this._handleRaceResults(raceResult);\n        if (raceResult.winner != null) {\n            if (GSNContractsDataTypes_1.isInfoFromEvent(raceResult.winner.relayInfo)) {\n                return raceResult.winner;\n            }\n            else {\n                const managerAddress = raceResult.winner.pingResponse.relayManagerAddress;\n                this.logger.info(`finding relay register info for manager address: ${managerAddress}; known info: ${JSON.stringify(raceResult.winner.relayInfo)}`);\n                const events = await this.knownRelaysManager.getRelayInfoForManagers(new Set([managerAddress]));\n                if (events.length === 1) {\n                    // as preferred relay URL is not guaranteed to match the advertised one for the same manager, preserve URL\n                    const relayInfo = events[0];\n                    relayInfo.relayUrl = raceResult.winner.relayInfo.relayUrl;\n                    return {\n                        pingResponse: raceResult.winner.pingResponse,\n                        relayInfo\n                    };\n                }\n                else {\n                    // TODO: do not throw! The preferred relay may be removed since.\n                    throw new Error('Could not find register event for the winning preferred relay');\n                }\n            }\n        }\n    }\n    async init() {\n        this.remainingRelays = await this.knownRelaysManager.getRelaysSortedForTransaction(this.gsnTransactionDetails);\n        this.isInitialized = true;\n        return this;\n    }\n    // relays left to try\n    // (note that some edge-cases (like duplicate urls) are not filtered out)\n    relaysLeft() {\n        return this.remainingRelays.flatMap(list => list);\n    }\n    _getNextSlice() {\n        if (!this.isInitialized) {\n            throw new Error('init() not called');\n        }\n        for (const relays of this.remainingRelays) {\n            const bulkSize = Math.min(this.config.sliceSize, relays.length);\n            const slice = relays.slice(0, bulkSize);\n            if (slice.length === 0) {\n                continue;\n            }\n            return slice;\n        }\n        return [];\n    }\n    /**\n     * @returns JSON response from the relay server, but adds the requested URL to it :'-(\n     */\n    async _getRelayAddressPing(relayInfo) {\n        this.logger.info(`getRelayAddressPing URL: ${relayInfo.relayUrl}`);\n        const pingResponse = await this.httpClient.getPingResponse(relayInfo.relayUrl, this.gsnTransactionDetails.paymaster);\n        if (!pingResponse.ready) {\n            throw new Error(`Relay not ready ${JSON.stringify(pingResponse)}`);\n        }\n        this.pingFilter(pingResponse, this.gsnTransactionDetails);\n        return {\n            pingResponse,\n            relayInfo\n        };\n    }\n    /**\n     * From https://stackoverflow.com/a/37235207 (added types, modified to catch exceptions)\n     * Accepts an array of promises.\n     * Resolves once any promise resolves, ignores the rest. Exceptions returned separately.\n     */\n    async _raceToSuccess(relays) {\n        const errors = new Map();\n        return await new Promise((resolve) => {\n            relays.forEach((relay) => {\n                this._getRelayAddressPing(relay)\n                    .then((winner) => {\n                    resolve({\n                        winner,\n                        errors\n                    });\n                })\n                    .catch((err) => {\n                    errors.set(relay.relayUrl, err);\n                    if (errors.size === relays.length) {\n                        resolve({ errors });\n                    }\n                });\n            });\n        });\n    }\n    _handleRaceResults(raceResult) {\n        if (!this.isInitialized) {\n            throw new Error('init() not called');\n        }\n        this.errors = new Map([...this.errors, ...raceResult.errors]);\n        this.remainingRelays = this.remainingRelays.map(relays => relays\n            .filter(eventInfo => { var _a; return eventInfo.relayUrl !== ((_a = raceResult.winner) === null || _a === void 0 ? void 0 : _a.relayInfo.relayUrl); })\n            .filter(eventInfo => !Array.from(raceResult.errors.keys()).includes(eventInfo.relayUrl)));\n    }\n}\nexports.RelaySelectionManager = RelaySelectionManager;\n//# sourceMappingURL=RelaySelectionManager.js.map"]},"metadata":{},"sourceType":"script"}