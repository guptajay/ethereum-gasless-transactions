{"ast":null,"code":"'use strict';\n\nvar format = require('./format');\n/*\r\n * function cascade(formats)\r\n * Returns a function that invokes the `._format` function in-order\r\n * for the specified set of `formats`. In this manner we say that Formats\r\n * are \"pipe-like\", but not a pure pumpify implementation. Since there is no back\r\n * pressure we can remove all of the \"readable\" plumbing in Node streams.\r\n */\n\n\nfunction cascade(formats) {\n  if (!formats.every(isValidFormat)) {\n    return;\n  }\n\n  return function (info) {\n    var obj = info;\n\n    for (var i = 0; i < formats.length; i++) {\n      obj = formats[i].transform(obj, formats[i].options);\n\n      if (!obj) {\n        return false;\n      }\n    }\n\n    return obj;\n  };\n}\n/*\r\n * function isValidFormat(format)\r\n * If the format does not define a `transform` function throw an error\r\n * with more detailed usage.\r\n */\n\n\nfunction isValidFormat(fmt) {\n  if (typeof fmt.transform !== 'function') {\n    throw new Error(['No transform function found on format. Did you create a format instance?', 'const myFormat = format(formatFn);', 'const instance = myFormat();'].join('\\n'));\n  }\n\n  return true;\n}\n/*\r\n * function combine (info)\r\n * Returns a new instance of the combine Format which combines the specified\r\n * formats into a new format. This is similar to a pipe-chain in transform streams.\r\n * We choose to combine the prototypes this way because there is no back pressure in\r\n * an in-memory transform chain.\r\n */\n\n\nmodule.exports = function () {\n  for (var _len = arguments.length, formats = new Array(_len), _key = 0; _key < _len; _key++) {\n    formats[_key] = arguments[_key];\n  }\n\n  var combinedFormat = format(cascade(formats));\n  var instance = combinedFormat();\n  instance.Format = combinedFormat.Format;\n  return instance;\n}; //\n// Export the cascade method for use in cli and other\n// combined formats that should not be assumed to be\n// singletons.\n//\n\n\nmodule.exports.cascade = cascade;","map":{"version":3,"sources":["C:/Users/nomif/Desktop/Programming/Blockchain/ethereum-gasless-transactions/OpenGSN/node_modules/logform/dist/combine.js"],"names":["format","require","cascade","formats","every","isValidFormat","info","obj","i","length","transform","options","fmt","Error","join","module","exports","_len","arguments","Array","_key","combinedFormat","instance","Format"],"mappings":"AAAA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,UAAD,CAApB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASC,OAAT,CAAiBC,OAAjB,EAA0B;AACxB,MAAI,CAACA,OAAO,CAACC,KAAR,CAAcC,aAAd,CAAL,EAAmC;AACjC;AACD;;AAED,SAAO,UAAUC,IAAV,EAAgB;AACrB,QAAIC,GAAG,GAAGD,IAAV;;AAEA,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,OAAO,CAACM,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;AACvCD,MAAAA,GAAG,GAAGJ,OAAO,CAACK,CAAD,CAAP,CAAWE,SAAX,CAAqBH,GAArB,EAA0BJ,OAAO,CAACK,CAAD,CAAP,CAAWG,OAArC,CAAN;;AAEA,UAAI,CAACJ,GAAL,EAAU;AACR,eAAO,KAAP;AACD;AACF;;AAED,WAAOA,GAAP;AACD,GAZD;AAaD;AACD;AACA;AACA;AACA;AACA;;;AAGA,SAASF,aAAT,CAAuBO,GAAvB,EAA4B;AAC1B,MAAI,OAAOA,GAAG,CAACF,SAAX,KAAyB,UAA7B,EAAyC;AACvC,UAAM,IAAIG,KAAJ,CAAU,CAAC,0EAAD,EAA6E,oCAA7E,EAAmH,8BAAnH,EAAmJC,IAAnJ,CAAwJ,IAAxJ,CAAV,CAAN;AACD;;AAED,SAAO,IAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGAC,MAAM,CAACC,OAAP,GAAiB,YAAY;AAC3B,OAAK,IAAIC,IAAI,GAAGC,SAAS,CAACT,MAArB,EAA6BN,OAAO,GAAG,IAAIgB,KAAJ,CAAUF,IAAV,CAAvC,EAAwDG,IAAI,GAAG,CAApE,EAAuEA,IAAI,GAAGH,IAA9E,EAAoFG,IAAI,EAAxF,EAA4F;AAC1FjB,IAAAA,OAAO,CAACiB,IAAD,CAAP,GAAgBF,SAAS,CAACE,IAAD,CAAzB;AACD;;AAED,MAAIC,cAAc,GAAGrB,MAAM,CAACE,OAAO,CAACC,OAAD,CAAR,CAA3B;AACA,MAAImB,QAAQ,GAAGD,cAAc,EAA7B;AACAC,EAAAA,QAAQ,CAACC,MAAT,GAAkBF,cAAc,CAACE,MAAjC;AACA,SAAOD,QAAP;AACD,CATD,C,CASG;AACH;AACA;AACA;AACA;;;AAGAP,MAAM,CAACC,OAAP,CAAed,OAAf,GAAyBA,OAAzB","sourcesContent":["'use strict';\r\n\r\nvar format = require('./format');\r\n/*\r\n * function cascade(formats)\r\n * Returns a function that invokes the `._format` function in-order\r\n * for the specified set of `formats`. In this manner we say that Formats\r\n * are \"pipe-like\", but not a pure pumpify implementation. Since there is no back\r\n * pressure we can remove all of the \"readable\" plumbing in Node streams.\r\n */\r\n\r\n\r\nfunction cascade(formats) {\r\n  if (!formats.every(isValidFormat)) {\r\n    return;\r\n  }\r\n\r\n  return function (info) {\r\n    var obj = info;\r\n\r\n    for (var i = 0; i < formats.length; i++) {\r\n      obj = formats[i].transform(obj, formats[i].options);\r\n\r\n      if (!obj) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return obj;\r\n  };\r\n}\r\n/*\r\n * function isValidFormat(format)\r\n * If the format does not define a `transform` function throw an error\r\n * with more detailed usage.\r\n */\r\n\r\n\r\nfunction isValidFormat(fmt) {\r\n  if (typeof fmt.transform !== 'function') {\r\n    throw new Error(['No transform function found on format. Did you create a format instance?', 'const myFormat = format(formatFn);', 'const instance = myFormat();'].join('\\n'));\r\n  }\r\n\r\n  return true;\r\n}\r\n/*\r\n * function combine (info)\r\n * Returns a new instance of the combine Format which combines the specified\r\n * formats into a new format. This is similar to a pipe-chain in transform streams.\r\n * We choose to combine the prototypes this way because there is no back pressure in\r\n * an in-memory transform chain.\r\n */\r\n\r\n\r\nmodule.exports = function () {\r\n  for (var _len = arguments.length, formats = new Array(_len), _key = 0; _key < _len; _key++) {\r\n    formats[_key] = arguments[_key];\r\n  }\r\n\r\n  var combinedFormat = format(cascade(formats));\r\n  var instance = combinedFormat();\r\n  instance.Format = combinedFormat.Format;\r\n  return instance;\r\n}; //\r\n// Export the cascade method for use in cli and other\r\n// combined formats that should not be assumed to be\r\n// singletons.\r\n//\r\n\r\n\r\nmodule.exports.cascade = cascade;"]},"metadata":{},"sourceType":"script"}