{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\n\nconst assert_1 = __importDefault(require(\"assert\"));\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst rlp = __importStar(require(\"rlp\"));\n\nconst secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\n\nconst ethjs_util_1 = require(\"ethjs-util\");\n\nconst constants_1 = require(\"./constants\");\n\nconst bytes_1 = require(\"./bytes\");\n\nconst hash_1 = require(\"./hash\");\n\nconst helpers_1 = require(\"./helpers\");\n\nconst types_1 = require(\"./types\");\n\nclass Account {\n  /**\r\n   * This constructor assigns and validates the values.\r\n   * Use the static factory methods to assist in creating an Account from varying data types.\r\n   */\n  constructor() {\n    let nonce = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new bn_js_1.default(0);\n    let balance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new bn_js_1.default(0);\n    let stateRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : constants_1.KECCAK256_RLP;\n    let codeHash = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : constants_1.KECCAK256_NULL;\n    this.nonce = nonce;\n    this.balance = balance;\n    this.stateRoot = stateRoot;\n    this.codeHash = codeHash;\n\n    this._validate();\n  }\n\n  static fromAccountData(accountData) {\n    const {\n      nonce,\n      balance,\n      stateRoot,\n      codeHash\n    } = accountData;\n    return new Account(nonce ? new bn_js_1.default(bytes_1.toBuffer(nonce)) : undefined, balance ? new bn_js_1.default(bytes_1.toBuffer(balance)) : undefined, stateRoot ? bytes_1.toBuffer(stateRoot) : undefined, codeHash ? bytes_1.toBuffer(codeHash) : undefined);\n  }\n\n  static fromRlpSerializedAccount(serialized) {\n    const values = rlp.decode(serialized);\n\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized account input. Must be array');\n    }\n\n    return this.fromValuesArray(values);\n  }\n\n  static fromValuesArray(values) {\n    const [nonce, balance, stateRoot, codeHash] = values;\n    return new Account(new bn_js_1.default(nonce), new bn_js_1.default(balance), stateRoot, codeHash);\n  }\n\n  _validate() {\n    if (this.nonce.lt(new bn_js_1.default(0))) {\n      throw new Error('nonce must be greater than zero');\n    }\n\n    if (this.balance.lt(new bn_js_1.default(0))) {\n      throw new Error('balance must be greater than zero');\n    }\n\n    if (this.stateRoot.length !== 32) {\n      throw new Error('stateRoot must have a length of 32');\n    }\n\n    if (this.codeHash.length !== 32) {\n      throw new Error('codeHash must have a length of 32');\n    }\n  }\n  /**\r\n   * Returns a Buffer Array of the raw Buffers for the account, in order.\r\n   */\n\n\n  raw() {\n    return [types_1.bnToRlp(this.nonce), types_1.bnToRlp(this.balance), this.stateRoot, this.codeHash];\n  }\n  /**\r\n   * Returns the RLP serialization of the account as a `Buffer`.\r\n   */\n\n\n  serialize() {\n    return rlp.encode(this.raw());\n  }\n  /**\r\n   * Returns a `Boolean` determining if the account is a contract.\r\n   */\n\n\n  isContract() {\n    return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n  }\n  /**\r\n   * Returns a `Boolean` determining if the account is empty complying to the definition of\r\n   * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\r\n   * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\r\n   */\n\n\n  isEmpty() {\n    return this.balance.isZero() && this.nonce.isZero() && this.codeHash.equals(constants_1.KECCAK256_NULL);\n  }\n\n}\n\nexports.Account = Account;\n/**\r\n * Checks if the address is a valid. Accepts checksummed addresses too.\r\n */\n\nexports.isValidAddress = function (hexAddress) {\n  try {\n    helpers_1.assertIsString(hexAddress);\n  } catch (e) {\n    return false;\n  }\n\n  return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\n/**\r\n * Returns a checksummed address.\r\n *\r\n * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\r\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\r\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\r\n *\r\n * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly\r\n * used variation in Ethereum was without the chainId. This may change in the future.\r\n */\n\n\nexports.toChecksumAddress = function (hexAddress, eip1191ChainId) {\n  helpers_1.assertIsHexString(hexAddress);\n  const address = ethjs_util_1.stripHexPrefix(hexAddress).toLowerCase();\n  let prefix = '';\n\n  if (eip1191ChainId) {\n    const chainId = types_1.toType(eip1191ChainId, types_1.TypeOutput.BN);\n    prefix = chainId.toString() + '0x';\n  }\n\n  const hash = hash_1.keccakFromString(prefix + address).toString('hex');\n  let ret = '0x';\n\n  for (let i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase();\n    } else {\n      ret += address[i];\n    }\n  }\n\n  return ret;\n};\n/**\r\n * Checks if the address is a valid checksummed address.\r\n *\r\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\r\n */\n\n\nexports.isValidChecksumAddress = function (hexAddress, eip1191ChainId) {\n  return exports.isValidAddress(hexAddress) && exports.toChecksumAddress(hexAddress, eip1191ChainId) === hexAddress;\n};\n/**\r\n * Generates an address of a newly created contract.\r\n * @param from The address which is creating this new address\r\n * @param nonce The nonce of the from account\r\n */\n\n\nexports.generateAddress = function (from, nonce) {\n  helpers_1.assertIsBuffer(from);\n  helpers_1.assertIsBuffer(nonce);\n  const nonceBN = new bn_js_1.default(nonce);\n\n  if (nonceBN.isZero()) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return hash_1.rlphash([from, null]).slice(-20);\n  } // Only take the lower 160bits of the hash\n\n\n  return hash_1.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);\n};\n/**\r\n * Generates an address for a contract created using CREATE2.\r\n * @param from The address which is creating this new address\r\n * @param salt A salt\r\n * @param initCode The init code of the contract being created\r\n */\n\n\nexports.generateAddress2 = function (from, salt, initCode) {\n  helpers_1.assertIsBuffer(from);\n  helpers_1.assertIsBuffer(salt);\n  helpers_1.assertIsBuffer(initCode);\n  assert_1.default(from.length === 20);\n  assert_1.default(salt.length === 32);\n  const address = hash_1.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, hash_1.keccak256(initCode)]));\n  return address.slice(-20);\n};\n/**\r\n * Checks if the private key satisfies the rules of the curve secp256k1.\r\n */\n\n\nexports.isValidPrivate = function (privateKey) {\n  return secp256k1_1.privateKeyVerify(privateKey);\n};\n/**\r\n * Checks if the public key satisfies the rules of the curve secp256k1\r\n * and the requirements of Ethereum.\r\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\r\n * @param sanitize Accept public keys in other formats\r\n */\n\n\nexports.isValidPublic = function (publicKey) {\n  let sanitize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  helpers_1.assertIsBuffer(publicKey);\n\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    return secp256k1_1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));\n  }\n\n  if (!sanitize) {\n    return false;\n  }\n\n  return secp256k1_1.publicKeyVerify(publicKey);\n};\n/**\r\n * Returns the ethereum address of a given public key.\r\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\r\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\r\n * @param sanitize Accept public keys in other formats\r\n */\n\n\nexports.pubToAddress = function (pubKey) {\n  let sanitize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  helpers_1.assertIsBuffer(pubKey);\n\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = Buffer.from(secp256k1_1.publicKeyConvert(pubKey, false).slice(1));\n  }\n\n  assert_1.default(pubKey.length === 64); // Only take the lower 160bits of the hash\n\n  return hash_1.keccak(pubKey).slice(-20);\n};\n\nexports.publicToAddress = exports.pubToAddress;\n/**\r\n * Returns the ethereum public key of a given private key.\r\n * @param privateKey A private key must be 256 bits wide\r\n */\n\nexports.privateToPublic = function (privateKey) {\n  helpers_1.assertIsBuffer(privateKey); // skip the type flag and use the X, Y points\n\n  return Buffer.from(secp256k1_1.publicKeyCreate(privateKey, false)).slice(1);\n};\n/**\r\n * Returns the ethereum address of a given private key.\r\n * @param privateKey A private key must be 256 bits wide\r\n */\n\n\nexports.privateToAddress = function (privateKey) {\n  return exports.publicToAddress(exports.privateToPublic(privateKey));\n};\n/**\r\n * Converts a public key to the Ethereum format.\r\n */\n\n\nexports.importPublic = function (publicKey) {\n  helpers_1.assertIsBuffer(publicKey);\n\n  if (publicKey.length !== 64) {\n    publicKey = Buffer.from(secp256k1_1.publicKeyConvert(publicKey, false).slice(1));\n  }\n\n  return publicKey;\n};\n/**\r\n * Returns the zero address.\r\n */\n\n\nexports.zeroAddress = function () {\n  const addressLength = 20;\n  const addr = bytes_1.zeros(addressLength);\n  return bytes_1.bufferToHex(addr);\n};\n/**\r\n * Checks if a given address is the zero address.\r\n */\n\n\nexports.isZeroAddress = function (hexAddress) {\n  try {\n    helpers_1.assertIsString(hexAddress);\n  } catch (e) {\n    return false;\n  }\n\n  const zeroAddr = exports.zeroAddress();\n  return zeroAddr === hexAddress;\n};","map":{"version":3,"sources":["../src/account.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\r\nconst assert_1 = __importDefault(require(\"assert\"));\r\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\r\nconst rlp = __importStar(require(\"rlp\"));\r\nconst secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\r\nconst ethjs_util_1 = require(\"ethjs-util\");\r\nconst constants_1 = require(\"./constants\");\r\nconst bytes_1 = require(\"./bytes\");\r\nconst hash_1 = require(\"./hash\");\r\nconst helpers_1 = require(\"./helpers\");\r\nconst types_1 = require(\"./types\");\r\nclass Account {\r\n    /**\r\n     * This constructor assigns and validates the values.\r\n     * Use the static factory methods to assist in creating an Account from varying data types.\r\n     */\r\n    constructor(nonce = new bn_js_1.default(0), balance = new bn_js_1.default(0), stateRoot = constants_1.KECCAK256_RLP, codeHash = constants_1.KECCAK256_NULL) {\r\n        this.nonce = nonce;\r\n        this.balance = balance;\r\n        this.stateRoot = stateRoot;\r\n        this.codeHash = codeHash;\r\n        this._validate();\r\n    }\r\n    static fromAccountData(accountData) {\r\n        const { nonce, balance, stateRoot, codeHash } = accountData;\r\n        return new Account(nonce ? new bn_js_1.default(bytes_1.toBuffer(nonce)) : undefined, balance ? new bn_js_1.default(bytes_1.toBuffer(balance)) : undefined, stateRoot ? bytes_1.toBuffer(stateRoot) : undefined, codeHash ? bytes_1.toBuffer(codeHash) : undefined);\r\n    }\r\n    static fromRlpSerializedAccount(serialized) {\r\n        const values = rlp.decode(serialized);\r\n        if (!Array.isArray(values)) {\r\n            throw new Error('Invalid serialized account input. Must be array');\r\n        }\r\n        return this.fromValuesArray(values);\r\n    }\r\n    static fromValuesArray(values) {\r\n        const [nonce, balance, stateRoot, codeHash] = values;\r\n        return new Account(new bn_js_1.default(nonce), new bn_js_1.default(balance), stateRoot, codeHash);\r\n    }\r\n    _validate() {\r\n        if (this.nonce.lt(new bn_js_1.default(0))) {\r\n            throw new Error('nonce must be greater than zero');\r\n        }\r\n        if (this.balance.lt(new bn_js_1.default(0))) {\r\n            throw new Error('balance must be greater than zero');\r\n        }\r\n        if (this.stateRoot.length !== 32) {\r\n            throw new Error('stateRoot must have a length of 32');\r\n        }\r\n        if (this.codeHash.length !== 32) {\r\n            throw new Error('codeHash must have a length of 32');\r\n        }\r\n    }\r\n    /**\r\n     * Returns a Buffer Array of the raw Buffers for the account, in order.\r\n     */\r\n    raw() {\r\n        return [types_1.bnToRlp(this.nonce), types_1.bnToRlp(this.balance), this.stateRoot, this.codeHash];\r\n    }\r\n    /**\r\n     * Returns the RLP serialization of the account as a `Buffer`.\r\n     */\r\n    serialize() {\r\n        return rlp.encode(this.raw());\r\n    }\r\n    /**\r\n     * Returns a `Boolean` determining if the account is a contract.\r\n     */\r\n    isContract() {\r\n        return !this.codeHash.equals(constants_1.KECCAK256_NULL);\r\n    }\r\n    /**\r\n     * Returns a `Boolean` determining if the account is empty complying to the definition of\r\n     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\r\n     * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\r\n     */\r\n    isEmpty() {\r\n        return this.balance.isZero() && this.nonce.isZero() && this.codeHash.equals(constants_1.KECCAK256_NULL);\r\n    }\r\n}\r\nexports.Account = Account;\r\n/**\r\n * Checks if the address is a valid. Accepts checksummed addresses too.\r\n */\r\nexports.isValidAddress = function (hexAddress) {\r\n    try {\r\n        helpers_1.assertIsString(hexAddress);\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n    return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\r\n};\r\n/**\r\n * Returns a checksummed address.\r\n *\r\n * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\r\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\r\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\r\n *\r\n * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly\r\n * used variation in Ethereum was without the chainId. This may change in the future.\r\n */\r\nexports.toChecksumAddress = function (hexAddress, eip1191ChainId) {\r\n    helpers_1.assertIsHexString(hexAddress);\r\n    const address = ethjs_util_1.stripHexPrefix(hexAddress).toLowerCase();\r\n    let prefix = '';\r\n    if (eip1191ChainId) {\r\n        const chainId = types_1.toType(eip1191ChainId, types_1.TypeOutput.BN);\r\n        prefix = chainId.toString() + '0x';\r\n    }\r\n    const hash = hash_1.keccakFromString(prefix + address).toString('hex');\r\n    let ret = '0x';\r\n    for (let i = 0; i < address.length; i++) {\r\n        if (parseInt(hash[i], 16) >= 8) {\r\n            ret += address[i].toUpperCase();\r\n        }\r\n        else {\r\n            ret += address[i];\r\n        }\r\n    }\r\n    return ret;\r\n};\r\n/**\r\n * Checks if the address is a valid checksummed address.\r\n *\r\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\r\n */\r\nexports.isValidChecksumAddress = function (hexAddress, eip1191ChainId) {\r\n    return exports.isValidAddress(hexAddress) && exports.toChecksumAddress(hexAddress, eip1191ChainId) === hexAddress;\r\n};\r\n/**\r\n * Generates an address of a newly created contract.\r\n * @param from The address which is creating this new address\r\n * @param nonce The nonce of the from account\r\n */\r\nexports.generateAddress = function (from, nonce) {\r\n    helpers_1.assertIsBuffer(from);\r\n    helpers_1.assertIsBuffer(nonce);\r\n    const nonceBN = new bn_js_1.default(nonce);\r\n    if (nonceBN.isZero()) {\r\n        // in RLP we want to encode null in the case of zero nonce\r\n        // read the RLP documentation for an answer if you dare\r\n        return hash_1.rlphash([from, null]).slice(-20);\r\n    }\r\n    // Only take the lower 160bits of the hash\r\n    return hash_1.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);\r\n};\r\n/**\r\n * Generates an address for a contract created using CREATE2.\r\n * @param from The address which is creating this new address\r\n * @param salt A salt\r\n * @param initCode The init code of the contract being created\r\n */\r\nexports.generateAddress2 = function (from, salt, initCode) {\r\n    helpers_1.assertIsBuffer(from);\r\n    helpers_1.assertIsBuffer(salt);\r\n    helpers_1.assertIsBuffer(initCode);\r\n    assert_1.default(from.length === 20);\r\n    assert_1.default(salt.length === 32);\r\n    const address = hash_1.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, hash_1.keccak256(initCode)]));\r\n    return address.slice(-20);\r\n};\r\n/**\r\n * Checks if the private key satisfies the rules of the curve secp256k1.\r\n */\r\nexports.isValidPrivate = function (privateKey) {\r\n    return secp256k1_1.privateKeyVerify(privateKey);\r\n};\r\n/**\r\n * Checks if the public key satisfies the rules of the curve secp256k1\r\n * and the requirements of Ethereum.\r\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\r\n * @param sanitize Accept public keys in other formats\r\n */\r\nexports.isValidPublic = function (publicKey, sanitize = false) {\r\n    helpers_1.assertIsBuffer(publicKey);\r\n    if (publicKey.length === 64) {\r\n        // Convert to SEC1 for secp256k1\r\n        return secp256k1_1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));\r\n    }\r\n    if (!sanitize) {\r\n        return false;\r\n    }\r\n    return secp256k1_1.publicKeyVerify(publicKey);\r\n};\r\n/**\r\n * Returns the ethereum address of a given public key.\r\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\r\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\r\n * @param sanitize Accept public keys in other formats\r\n */\r\nexports.pubToAddress = function (pubKey, sanitize = false) {\r\n    helpers_1.assertIsBuffer(pubKey);\r\n    if (sanitize && pubKey.length !== 64) {\r\n        pubKey = Buffer.from(secp256k1_1.publicKeyConvert(pubKey, false).slice(1));\r\n    }\r\n    assert_1.default(pubKey.length === 64);\r\n    // Only take the lower 160bits of the hash\r\n    return hash_1.keccak(pubKey).slice(-20);\r\n};\r\nexports.publicToAddress = exports.pubToAddress;\r\n/**\r\n * Returns the ethereum public key of a given private key.\r\n * @param privateKey A private key must be 256 bits wide\r\n */\r\nexports.privateToPublic = function (privateKey) {\r\n    helpers_1.assertIsBuffer(privateKey);\r\n    // skip the type flag and use the X, Y points\r\n    return Buffer.from(secp256k1_1.publicKeyCreate(privateKey, false)).slice(1);\r\n};\r\n/**\r\n * Returns the ethereum address of a given private key.\r\n * @param privateKey A private key must be 256 bits wide\r\n */\r\nexports.privateToAddress = function (privateKey) {\r\n    return exports.publicToAddress(exports.privateToPublic(privateKey));\r\n};\r\n/**\r\n * Converts a public key to the Ethereum format.\r\n */\r\nexports.importPublic = function (publicKey) {\r\n    helpers_1.assertIsBuffer(publicKey);\r\n    if (publicKey.length !== 64) {\r\n        publicKey = Buffer.from(secp256k1_1.publicKeyConvert(publicKey, false).slice(1));\r\n    }\r\n    return publicKey;\r\n};\r\n/**\r\n * Returns the zero address.\r\n */\r\nexports.zeroAddress = function () {\r\n    const addressLength = 20;\r\n    const addr = bytes_1.zeros(addressLength);\r\n    return bytes_1.bufferToHex(addr);\r\n};\r\n/**\r\n * Checks if a given address is the zero address.\r\n */\r\nexports.isZeroAddress = function (hexAddress) {\r\n    try {\r\n        helpers_1.assertIsString(hexAddress);\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n    const zeroAddr = exports.zeroAddress();\r\n    return zeroAddr === hexAddress;\r\n};\r\n//# sourceMappingURL=account.js.map"]},"metadata":{},"sourceType":"script"}